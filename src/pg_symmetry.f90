module point_group_symmetry

! Module for handling point group symmetry, as read in from FCIDUMP files.

! This was made much easier thanks to conversations with Alex Thom...

! NOTE:
! It seems physicists are far less obsessed with point group symmetries than my
! undergraduate chemistry course.  I recommend a thorough reading of the
! relevant sections of the classic book 'Group Theory and Quantum Mechanics' by
! Tinkham.

! Point group symmetry
! --------------------
!
! The quantum chemistry packages we use to generate FCIDUMP files only implement
! D2h symmetry (and subgroups thereof).  Whilst this means some symmetries are
! not considered, the advantage for us is that all point groups we will consider
! are real and Abelian.  Thus:
!
! * all irreducible representations are 1D.
! * all operations are their own inverse
! * \Gamma_i \cross \Gamma_i = \Gamma_1, where \Gamma_i is an arbitrary
!   irreducible representation, \cross indicates direct product and \Gamma_1 is
!   the totally-symmetric representation.
! * all irreducible representations can be represented by (at most) three
!   generators and the behaviour of a function under those generators is
!   sufficient to completely determine the symmetry of that function.
!
! Furthermore, we assume that each basis function spans one (and only one)
! irreducible representation---this can always be done when working in D2h (or
! a subgroup thereof).
!
! An irreducible representation is labelled by its behaviour under the
! generators of the point group using a bit string where the i-th bit
! corresponds to the i-th generator.  A set bit indicates that the
! representation is *odd* with respect to that generator and an unset bit
! indicates that the representation is *even* with respect to that generator.
! Thus the totally symmetric representation is always labelled by the 0 bit
! string.
!
! Direct products are easily evaluated by considering the characters of the
! generator operations in the product: even \cross even = even, odd \cross odd = even
! and odd \cross even = odd.  Hence the direct product can be found by
! taking XOR of the representations involved.
!
! As we consider (at most) D2h (3 generators) we can just use a standard integer
! to represent the irreducible representations.  The higher bits are wasted, but
! the memory used is minimal.
!
! For a point group containing n generators, there are 2^n irreducible
! representations.  Due to the bit representation described above, these
! representations are labelled by the set of integers {0,1,...2^n-1}.

use const

implicit none

! Following the above discussion, the totally symmetric representation is given
! by the null bit string (with some Lz symmetry which is added later)
integer :: gamma_sym = 0


! The following arrays are used to store information about number of basis functions
! of a given symmetry.  With Lz symmetry (which is not closed), the symmetries which can 
! be generated by products of basis fns (sym indices sym0_tot:sym_max_tot)are more than
! the basis functions themselves (sym0:sym_max).
! For speed within the excitation generators, it was decided to have these arrays over 
! The whole symmetry range to avoid a test for validity, though they are zero outside
! the sym0:sym_max range.
! 
! nbasis_sym(i) gives the number of (spin) basis functions in the i-th symmetry,
! where i is the bit string describing the irreducible representation.
integer, allocatable :: nbasis_sym(:) ! (sym0_tot:sym_max_tot)

! nbasis_sym_spin(1,i) gives the number of spin-down basis functions in the i-th
! symmetry where i is the bit string describing the irreducible representation.
! Similarly, j=2 gives the analagous quantity for spin-up basis functions.
! For RHF calculations nbasis_sym_spin(:,i) = nbasis_sym(i)/2.
integer, allocatable :: nbasis_sym_spin(:,:) ! (2,sym0_tot:sym_max_tot)

! sym_spin_basis_fns(:,ims,isym) gives the list of spin functions (ims=1 for
! down, ims=2 for up) with symmetry isym.  We merrily waste some memory (not all
! symmetries will have the same number of basis functions), so a 0 entry
! indicates no more basis functions with the given spin and spatial symmetries.
integer, allocatable :: sym_spin_basis_fns(:,:,:) ! (max(nbasis_sym_spin),2,sym0_tot:sym_max_tot)

! The following masks are used to extract the point-group symmetry from the symmetry of a basis fn.
! pg symmetry occupies the lowest bits, and is extracted by iand with this mask.
integer :: pg_mask  ! Typically 0, 1, 3, or 7 depending on how many point-group operations there are.

! Lz symmetry is stored in the higher bits of the symmetry and this mask can be used to access it.
integer :: Lz_mask

! Used to offset the Lz values when encoding into a symmetry.  If iand(sym,Lz_mask)==Lz_offset,
! this corresponds to an Lz value of 0.
integer :: Lz_offset

! * or / by Lz_divisor to move the Lz values from higher bits to lower ones.
! NB this is not used in time-critical applications, so needn't be a shift rather than *,/
! To extract an Lz value from a symmetry sym, use (iand(sym,Lz_mask)-Lz_offset)/Lz_divisor
! or (better) use pg_sym_getLz().
integer :: Lz_divisor
contains

    subroutine init_pg_symmetry(sys)

        ! Initialise point group symmetry information.
        ! *Must* be called after basis functions are initialised and have their
        ! symmetries set from the FCIDUMP file.

        ! In/Out:
        !    sys: system being studied.  On output the symmetry fields are set.

        use checking, only: check_allocate

        use system, only: sys_t

        type(sys_t), intent(inout) :: sys

        integer :: i, ierr, ims, ind

        integer :: maxsym, maxLz
        ! molecular systems use symmetry indices starting from 0.
        sys%sym0 = 0

        ! Given n generators, there must be 2^n irreducible representations.
        ! in the working space.  (Note that the wavefunctions might only span
        ! a subspace of the point group considered by the generating quantum
        ! chemistry package.)
        ! Set maxsym to be 2^n so that we always work in the smallest group
        ! spanned by the wavefunctions.
        ! +1 comes from the fact that the basis_fn%sym gives the bit string
        ! representation.

        maxsym = 2**ceiling(log(real(maxval(sys%basis%basis_fns(:)%sym)+1))/log(2.0))
        
        if(sys%read_in%useLz) then
            ! This is the Max Lz value we find in the basis functions.
            maxLz = maxval(sys%basis%basis_fns(:)%lz)
        else
            maxLz = 0 ! Let's not use Lz.
        endif
        ! The point group mask is used to extract the point group symmetry from a sym.
        ! Since the point group sym goes from 0..maxsym-1, and maxsym is always a power
        ! of 2, the mask is just maxsym-1
        pg_mask = maxsym-1

        ! We'll put Lz in higher bits, and an encode or decode by multiplying or diviging by:
        Lz_divisor = maxsym

        ! When we use excitation generators, we combine together at most three orbitals'
        ! symmetries. The maximum encountered value of Lz will therefore be maxLz*3 
        ! (and the minimum the negative of this).
        ! We allocate bits for this above the pointgroup symmetry bits.
        ! If using renormalized excitation generators, we iterate over all possible symmetries
        ! so we wish to keep the number of symmetries as low as possible.  We therefore
        ! compromise on allowing Lz values from -3*MaxLz ... 3*MaxLz, which will
        ! be stored in the higher bits of the sym using this mask.
        Lz_mask = (2**ceiling(log(real(6*maxLz+1))/log(2.0))-1)*Lz_divisor
        ! However, in order to store these, two's complement is not a good idea as it does
        ! not provide a continuous set of numbers (e.g. in three bits, -1,0,1 would render
        ! as 111,000,001, and if these are stored as the higher bits of symmetry, they would
        ! provide too many symmetries to iterate over.
        ! e.g. if we had a single point-group bit, the allowed symmetries would be
        ! 1110, 1111, 0000, 0001, 0010, 0011 which are not continuous integers (when stored 32-bit)
        ! (unless we sign extend - I didn't want to get into that.)
        ! To make things continuous, we add Lz_offset to the Lz value so it always becomes positive.
        ! e.g. here, we would want to offset Lz by 1 (to get 0,1,2) so we set Lz_offset to 
        ! 0010 (putting it in the right place in the bit string), giving symmetries:
        ! 0000, 0001, 0010, 0011, 0100, 0101 which are continuous integers.
        ! For reference in Lz world, 0 means Lz=-3*maxLz*maxsym, so Lz_offset means Lz=0
        Lz_offset = 3*maxLz*Lz_divisor
        gamma_sym = Lz_offset

        if(sys%symmetry /= huge(1)) then
            ! If one wished to specify Lz in sys%symmetry, it would be added in here.
            ! Need to modify to include Lz:
            sys%symmetry = sys%symmetry + Lz_offset
        endif

        ! nsym, sym0 and sym_max allow one to iterate over the symmetries that occur in
        ! the basis fns:
        sys%sym0 = iand((-maxLz*Lz_divisor+Lz_offset),Lz_mask)
        sys%sym_max = maxLz*Lz_divisor+Lz_offset+maxsym-1
        sys%nsym = sys%sym_max - sys%sym0
        ! We can iterate from sys%sym0 .. sys%sym_max, which following the above discussion means
        sys%sym0_tot = 0
        sys%nsym_tot = (6*maxLz+1)*Lz_divisor
        sys%sym_max_tot = sys%nsym_tot-1

        allocate(nbasis_sym(sys%sym0_tot:sys%sym_max_tot), stat=ierr)
        call check_allocate('nbasis_sym', sys%nsym_tot, ierr)
        allocate(nbasis_sym_spin(2,sys%sym0_tot:sys%sym_max_tot), stat=ierr)
        call check_allocate('nbasis_sym_spin', 2*sys%nsym_tot, ierr)

        nbasis_sym = 0
        nbasis_sym_spin = 0

        associate(nbasis=>sys%basis%nbasis, basis_fns=>sys%basis%basis_fns)
            do i = 1, nbasis
                ! Encode the Lz into the symmetry. We shift the lz into higher bits (by *maxsym)  and offset.
                if (maxLz>0) then
                    basis_fns(i)%sym = basis_fns(i)%sym + (basis_fns(i)%lz*Lz_divisor+Lz_offset)
                endif
                nbasis_sym(basis_fns(i)%sym) = nbasis_sym(basis_fns(i)%sym) + 1
                basis_fns(i)%sym_index = nbasis_sym(basis_fns(i)%sym)

                ims = (basis_fns(i)%Ms+3)/2 ! Ms=-1,1 -> ims=1,2

                nbasis_sym_spin(ims,basis_fns(i)%sym) = nbasis_sym_spin(ims,basis_fns(i)%sym) + 1
                basis_fns(i)%sym_spin_index = nbasis_sym_spin(ims,basis_fns(i)%sym)

            end do
        end associate

        allocate(sym_spin_basis_fns(maxval(nbasis_sym_spin),2,sys%sym0_tot:sys%sym_max_tot), stat=ierr)
        call check_allocate('sym_spin_basis_fns', maxval(nbasis_sym_spin)*2*sys%nsym_tot, ierr)
        sym_spin_basis_fns = 0

        do i = 1, sys%basis%nbasis
            ims = (sys%basis%basis_fns(i)%Ms+3)/2 ! Ms=-1,1 -> ims=1,2
            ind = minloc(sym_spin_basis_fns(:,ims,sys%basis%basis_fns(i)%sym), dim=1) ! first non-zero element
            sym_spin_basis_fns(ind, ims, sys%basis%basis_fns(i)%sym) = i
        end do

    end subroutine init_pg_symmetry

    subroutine end_pg_symmetry()

        ! Deallocate arrays containing point group symmetry information.

        use checking, only: check_deallocate

        integer :: ierr

        if (allocated(nbasis_sym)) then
            deallocate(nbasis_sym, stat=ierr)
            call check_deallocate('nbasis_sym', ierr)
        end if
        if (allocated(nbasis_sym_spin)) then
            deallocate(nbasis_sym_spin, stat=ierr)
            call check_deallocate('nbasis_sym_spin', ierr)
        end if
        if (allocated(sym_spin_basis_fns)) then
            deallocate(sym_spin_basis_fns, stat=ierr)
            call check_deallocate('sym_spin_basis_fns', ierr)
        end if

    end subroutine end_pg_symmetry

    subroutine print_pg_symmetry_info(sys)

        ! Write out point group symmetry information.

        ! In:
        !    sys: system being studied.

        use system, only: sys_t
        use parallel, only: parent
        use utils, only: int_fmt

        type(sys_t), intent(in) :: sys

        integer :: i, j, sym

        if (parent) then
            write (6,'(1X,a20,/,1X,20("-"),/)') "Symmetry information"

            write(6,'(1X,"Number of point group symmetries:",'//int_fmt(Lz_divisor,1)//')') Lz_divisor
            if(sys%read_in%useLz) then
                ! This is the Max Lz value we find in the basis functions.
                i = maxval(sys%basis%basis_fns(:)%lz)
                write(6,'(1X,"Maximum Lz found:",'//int_fmt(i,1)//')') i
                write(6,'(1X,"Lz offset (corresponds to Lz=0):",'//int_fmt(Lz_offset,1)//')') Lz_offset
            else
                write(6,'(1X,"Not using Lz symmetry.")')
            endif
            write(6,'(1X,"Totally symmetric symmetry:",'//int_fmt(gamma_sym,1)//')') gamma_sym
            write (6,'(1X,a78,/)') 'The matrix below gives the direct products of the irreducible representations.'
            ! Note that we never actually store this.
            do i = sys%sym0, sys%sym_max
                do j = sys%sym0, sys%sym_max
                    sym=cross_product_pg_sym(i,j)
                    if (sym>=sys%sym0_tot.and.sym<sys%nsym_tot) then
                        write (6,'(1X,i2)',advance='no') sym
                    else
                        write (6,'(3X)',advance='no')
                    endif
                end do
                write (6,'()')
            end do

            write (6,'(/,1X,a93,/)') 'The table below gives the number of basis functions spanning each irreducible representation.'

            write (6,'(1X,"irrep  Lz   sym  nbasis  nbasis_up  nbasis_down")')
            do i = sys%sym0, sys%sym_max
                write (6,'(1X,i3,3X,i3,3X,i2,2X,i5,3X,i5,6X,i5)') i, pg_sym_getLz(i), iand(i,pg_mask), nbasis_sym(i), &
                    nbasis_sym_spin(:,i)
            end do

            write (6,'()')

        end if

    end subroutine print_pg_symmetry_info

    pure function cross_product_pg_basis(i, j, basis_fns) result(sym_ij)

        ! In:
        !    i,j: (indices of) spin-orbitals.
        ! Returns:
        !    The bit string representation of the irreducible representation
        !    formed from the direct product i%sym \cross j%sym, where i%sym is
        !    the irreducible representation spanned by the i-th spin-orbital
        !    which can also potentially include an Lz symmetry.

        use basis_types, only: basis_fn_t

        integer :: sym_ij
        integer, intent(in) :: i, j
        type(basis_fn_t), intent(in) :: basis_fns(:)

        sym_ij = cross_product_pg_sym(basis_fns(i)%sym, basis_fns(j)%sym)

    end function cross_product_pg_basis

    elemental function cross_product_pg_sym(sym_i, sym_j) result(sym_ij)

        ! In:
        !    sym_i,sym_j: bit string representations of irreducible
        !    representations of a point group and Lz symmetry
        ! Returns:
        !    The bit string representation of the irreducible representation
        !    formed from the direct product sym_i \cross sym_j.
        !    The Lz part of the symmetry is split off and handled separately from the
        !    rest, and then reintegrated.

        integer :: sym_ij
        integer, intent(in) :: sym_i, sym_j

        ! The pg part can be done with an exclusive or. To save on operations, we mask after that.
        ! The Lz is just additive (though we need to extract it and remember to remove an offset).
        sym_ij = ior(iand(ieor(sym_i, sym_j),pg_mask), &
                iand(sym_i,Lz_mask)+iand(sym_j,Lz_mask)-Lz_offset)

    end function cross_product_pg_sym


    elemental function pg_sym_conj(sym) result(rsym)

        ! In:
        !   sym: the bit representation of the irrep of the pg sym including
        !        Lz in its higher bits 
        ! Returns:
        !   The symmetry conjugate of the symmetry. For pg symmetry this is the same as
        !   it's Abelian, but we need to take Lz to -Lz here.

        integer, intent(in) :: sym
        integer :: rsym

        ! Take the symmetry conjugate.  The point group part is the same.
        ! The Lz needs to become -Lz but also dealing with the offsetting.
        rsym  = ior(iand(sym,pg_mask), &
                iand(2*Lz_offset-iand(sym,Lz_mask),Lz_mask))

    end function pg_sym_conj

    elemental function pg_sym_getLz(sym) result(Lz)

        ! In:
        !    sym: bit string representation of an irreducible representation of
        !    a point group.
        ! Returns:
        !    The Lz component of sym (de-offsetted), so Lz=0 is returned as 0

        integer, intent(in) :: sym
        integer :: Lz
        Lz = (iand(sym,Lz_mask)-Lz_offset)/Lz_divisor

    end function pg_sym_getLz

    elemental function is_basis_pg_sym(sys,sym) result(valid)
        
        ! In:
        !    sys: system being studied
        !    sym: bit string representation of an irreducible representation of
        !    a point group.
        !
        ! Returns:
        !   True if sym could have been one of the basis function symmetries
        !   False otherwise

        use system, only: sys_t
        logical :: valid
        type(sys_t), intent(in) :: sys
        integer, intent(in) :: sym
        valid = sym>=sys%sym0 .and. sym<=sys%sym_max

    end function is_basis_pg_sym 

    elemental function is_gamma_irrep_pg_sym(sym) result(is_gamma)

        ! In:
        !    sym: bit string representation of an irreducible representation of
        !    a point group.
        ! Returns:
        !    True if sym represents the Gamma_1 (totally symmetric) irreducible
        !    representation.

        logical :: is_gamma
        integer, intent(in) :: sym

        is_gamma = gamma_sym == sym

    end function is_gamma_irrep_pg_sym

    pure function symmetry_orb_list_mol(basis, orb_list) result(isym)

        ! In:
        !    basis: info about the single particle basis set.
        !    orb_list: list of orbitals (e.g. determinant).
        ! Returns:
        !    symmetry index of list (i.e. direct product of the representations
        !    of all the orbitals in the list).

        use basis_types, only: basis_t

        integer :: isym
        type(basis_t), intent(in) :: basis
        integer, intent(in) :: orb_list(:)

        integer :: i

        isym = gamma_sym
        do i = lbound(orb_list, dim=1), ubound(orb_list, dim=1)
            isym = cross_product_pg_sym(isym, basis%basis_fns(orb_list(i))%sym)
        end do

    end function symmetry_orb_list_mol

end module point_group_symmetry
