User's Guide
============

Introduction
------------

HANDE contains optimised, highly parallel implementations of the full configuration
interaction quantum Monte Carlo (FCIQMC) [BoothThomAlavi09]_ and coupled cluster
Monte Carlo (CCMC) [Thom10]_ algorithms for a variety of systems.  Development work
continues to add new features and investigate the algorithms and new applications.

HANDE can perform calculations on generic systems such as molecules via an externally
generated integral file. The integral file is in the FCIDUMP format
[KnowlesHandy89]_, which can be generated by several quantum chemistry codes such as
MOLPRO, Q-Chem (with patches from Alex Thom) and PSI4 (with a plugin from James
Spencer).  HANDE can also perform calculations on model Hamiltonians, for which no
additional integrals are required.  The model Hamiltonians currently available are the
Hubbard model, Heisenberg model and uniform electron gas.

Configuration interaction (CI) is also implemented using external libraries
(lapack/scalapack and TRLan respectively) and can be performed in both serial and
parallel.  Lanczos diagonalisation can also be performed with or without precomputing the
Hamiltonian matrix.  Note that this is rather slow and intended for debugging purposes
only.  Most quantum chemistry codes (e.g. PSI4) contain a substantially more powerful and
optimised CI implementation.

Directory structure
--------------------

./
    Root directory of the program.
bin/
  Directory containing the compiled program, hande.x.  Created during
  compilation.
config/
  Directory containing the configuration input files used to generate makefiles.
dest/
  Directory containing the compiled object files and dependency files.  Created
  during compilation.
documentation/
   Directory containing documentation on the HANDE program.  The
   documentation is written in reStructured Text and can be converted
   into a wide range of output formats.
src/
    Directory containing the main source files.
lib/
   Directory containing "library" source files.  These a procedures which are
   not specific to the HANDE code but are generally useful.  Some are written
   by the authors, some are freely available (as noted in the source files).
tools/
    Directory containing scripts and tools for compiling, running and analysing
    output from HANDE.
test_suite/
    Directory containing a set of tests which HANDE should agree with.

Compilation
-----------

HANDE requires the lapack (http://www.netlib.org/lapack/), blas
(http://www.netlib.org/blas), TRLan
(http://crd-legacy.lbl.gov/~kewu/trlan.html), and lua (http://www.lua.org) (version 5.2) libaries.
The dependency upon TRLan
can be removed at compile-time by disabling the Lanczos functionality.
In addition, it requires the HDF5 library compiled with fortran 2003 support (see,
for example, http://www.cmth.ph.ic.ac.uk/computing/software/hdf5.html#admin-notes )
and the libuuid library (from, for example the uuid-dev Ubuntu package).

The code imports the AOTUS library which functions with lua 5.2 but not lua 5.3

After meeting these requirements, produce a makefile by running the mkconfig.py
(residing in the tools subdirectory) script in the root directory:

.. code-block:: bash

    tools/mkconfig.py config

where config is one of the platforms available.  The config name is simply the
name of the relevant file residing in the config/ directory.  Various configurations
are provided and it is simple to adapt one to the local environment (e.g. changing
compiler or library paths).

Run

.. code-block:: bash

    tools/mkconfig.py --help

to see the options available, including inspecting available platforms.
A platform is defined using a simple ini file, consisting of three sections:
main, opt and dbg.  For instance::

    [main]
    fc = gfortran
    ld = gfortran
    libs = -llapack -lblas

    [opt]
    fflags = -O3

    [dbg]
    fflags = -g

Any option not specified in the 'opt' and 'dbg' sections is inherited from the
'main' section.  The optimised settings in 'opt' are used by default; the debug
options can be selected by passing the -g option to mkconfig.py.

Available options are:

fc
    Set the fortran compiler.
fflags
    Set flags to be passed to the fortran compiler during compilation.
cxx
    Set the C++ compiler.
cxxflags
    Set flags to be passed to the C++ compiler during compilation.
cppdefs
    Set definitions to be used in the C pre-processing step.
cppflags
    Set flags to be used in the C pre-processing step.
ld
    Set the linker program.
ldflags
    Set flags to be passed to the linker during linking of the compiled objects.
libs
    Set libraries to be used during the linking step.
module_flag
    Set the compiler-specific flag which specifies the directory where module
    (.mod) files are placed when created and where they should be searched for.

To compile the code run 

.. code-block:: bash

    make
    
hande.x uses the sfmakedepend script (http://www.arsc.edu/~kate/Perl/,
supplied in tools/) by Kate Hedstrom to generate the dependencies.  These are
generated automatically when make is run if the dependency files don't exist.

The executable, hande.x, is placed in the bin subdirectory.  Note that this is
actually a symbolic link: a unique executable is produced for each platform and
optimisation level and hande.x merely points to the most recently compiled executable
for convenience.  This makes testing against multiple platforms particularly easy.

There are various goals in the makefile.  Run

.. code-block:: bash

    make help

to see the available goals.

Compile-time settings
^^^^^^^^^^^^^^^^^^^^^

The behaviour of the program can be changed in various ways by some choices at
compile-time by using C pre-processing.  These choices largely influence the
speed, memory usage, inclusion of parallel code and workarounds for certain
compilers.

The pre-processing options which accept a value are set by::

    -DOPTION=VAL

which defines the pre-processing definition OPTION to have value VAL.
Similarly, the options which just need to be defined to be used are set by::

    -DOPTION

These should be added to the cppflags or cppdefs lines in the configuration
files or in the Makefile, as desired.

DET_SIZE
    Default: 32.

    HANDE uses bit strings to store Slater determinants, where each bit
    corresponds to an occupied spin-orbital if the bit is set and an unoccupied
    spin orbital otherwise.  As fortran does not include a type for a single
    bit, integers are used.  Note that this does lead to some wasted memory when
    the number of spin-orbitals is not a multiple of the size of the integer used.
    An array of integers is used to store the determinant bit string if
    a single integer is not sufficient.

    This option sets the integer length to be used.  Allowed values are 32 and
    64, corresponding to using 32-bit and 64-bit integers respectively.  As bit
    operations on a 64-bit integer are faster than those on two 32-bit integers,
    using DET_SIZE=64 is recommended for production calculations.  (Note,
    however, that this will use more memory than DET_SIZE=32 if the number of
    basis functions is closer to a multiple of 32 rather than 64.  This is
    rarely a concern in practice.)
POP_SIZE
    Default: 32

    This option is used to specify whether 32 or 64-bit integers are used to
    store walker populations in HANDE. It is unlikely that 64-bit integers will
    be needed when using the integer code but this option is more critical
    when the **real_amplitudes** option is being used. When using the
    **real_amplitudes** option with POP_SIZE=32, the largest walker amplitude
    that can be stored is 2^20=1048576, while the smallest fractional part that
    can be represented is 2^-11=0.00049. When using this option and POP_SIZE=64
    the largest amplitude is 2^32=4.3x10^9 and the smallest fractional part
    is 2^-31=4.66x10^-10.
DISABLE_LANCZOS
    Default: not defined.

    If defined then Lanczos diagonalisation is disabled.  This removes the dependency on the TRLan
DISABLE_HDF5
    Default: not defined.

    If defined then the QMC restart functionality is disabled and the dependency on HDF5
    (which can be tricky to compile on some machines) is removed.  Note that restart
    functionality is extremely useful in production simulations so this option should
    only be used during initial porting efforts.
DSFMT_MEXP 
    Default: 19937.

    HANDE uses the dSFMT random number generator (RNG).  It is based on
    a Mersenne Twister algorithm, is extremely fast and produces high quality
    random numbers.  See http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html 
    for more details. 

    DSFMT_EXP sets the exponent of the period of the RNG.  Allowed values are
    521, 1279, 2203, 4253, 11213, 19937, 44497, 86243,
    132049 and 216091 and lead to, for example, random numbers with a period of
    a Mersenne Prime such as 2^512-1.
NAGF95  
    Default: not defined.

    If defined then code specific to, and necessary for compilation using, the
    NAG Fortran compiler is included.
PARALLEL  
    Default: not defined.

    Include source code required for running in parallel.
SINGLE_PRECISION  
    Default: not defined.

    Set the precision (where possible) to be single precision.  The default is
    double precision.  This is faster, but (of course) can change results
    significantly.  Use with care.
USE_POPCNT
    Default: not defined.

    Use the intrinsic popcnt function instead of the version implemented in HANDE.

    An important procedure involves counting the number of set bits in an integer.  HANDE
    includes a very efficient, branchless procedure to do this.  However, the Fortran
    2008 standard includes an intrinsic function, popcnt, for this exact operation.
    The performance of this intrinsic will be implementation-dependent and, with
    standard compilation flags, we expect the HANDE version to be competitive or more
    performant, based upon some simple tests.  The key difference is on modern
    processors containing the popcnt instruction: the popcnt intrinsic can then
    make use of this instruction and will be much faster than the implmentation
    in HANDE.  The existence of the popcnt instruction can be found, on Unix
    and Linux platforms, by inspecting the flags field in ``/proc/cpuinfo``: if
    it contains ``popcnt``, then the processor contains the popcnt instruction.

    Using the popcnt instruction often involves a compiler-specific flag to
    tell the compiler to use that instruction set; often compilers include the
    popcnt instruction with the flag that specifies the use of the SSE4.2
    instruction set.  The use of the popcnt instruction can be tested using
    objdump.  For example:

    .. code-block:: bash

        $ objdump -d bin/hande.x | grep popc
        0000000000400790 <__popcountdi2@plt>:
          400931:e8 5a fe ff ff         callq  400790 <__popcountdi2@plt>

    indicates that HANDE is using a compiler-supplied function for popcnt.  Exact output
    (especially the function name) is compiler dependent.  In contrast:

    .. code-block:: bash

        $ objdump -d bin/hande.x | grep popc
          4008ac:f3 0f b8 c0            popcnt %eax,%eax

    indicates HANDE is using the popcnt instruction.  If the above command does not give
    any output, then USE_POPCNT has most likely not been defined.

Usage
-----

.. code-block:: bash

    hande.x [input_filename]

If no input filename is provided then the input options are read from STDIN.
Note that this feature is not guaranteed to work when run in parallel!

Output is sent to STDOUT and can be redirected as desired.

hande.x only performs i/o operations on the root processor when run on
multiple processors.

Running tests
-------------

The tests are run using the ``testcode`` package (https://github.com/jsspencer/testcode).  testcode can be run from the test_suite subdirectory:

.. code-block:: bash

    testcode.py

Note that the default set of tests are serial only.  The entire test suite is
run every night using buildbot (http://www.cmth.ph.ic.ac.uk/buildbot/hande/).

Selected data from the HANDE output is compared to known 'good' results
('benchmarks').  The python script which extracts this data uses the pandas
module and, unfortunately, importing pandas is actually the time-consuming step
in the data analysis.  To help alleviate this, the data extraction script, can
be run in a server-client mode.  The server can be launched using:

.. code-block:: bash

    tools/tests/extract_test_data.py --socket &

If a server (on the default port) is running, the data extraction script used
by testcode will automatically use it, greatly speeding up the data analysis
step.

testcode is quite flexible and it's easy to run subsets of tests, check against
different benchmarks, compare previously run tests, run tests concurrently for
speed, etc.  Please see the testcode documentation for more details.

.. note::

    For algorithmic reasons, certain compilation options (principally POP_SIZE
    and DET_SIZE and processor/thread count) result in different Markov chains
    and hence different exact results (but same results on average).  The tests
    should therefore be run using the same compilatition options and the same
    parallel distribution as was used for the benchmarks.  The latter for MPI
    parallelisation is done automatically by testcode.  Separate tests exist
    for both POP_SIZE=32 and POP_SIZE=64.

    Currently there are no QMC tests suitable for OpenMP parallelisation due to
    difficulties with making the scheduler behave deterministically without
    affecting performance of production simulations.
    It is advised that you make sure to set the shell varialble OMP_NUM_THREADS
    to 1 when running the test suite - otherwise these will all be marked SKIPPED.

What if the tests fail?
-----------------------
A common cause for tests failing is that the configuration causes a different Markov
Chain to be run, or part of the code has been disabled in your build.
testcode should determine that some tests are inappropriate and skip them.
To force testcode to skip some tests, see below.

A second cause of failure is that some floating point values have rounded differently on
different architectures.
The tolerances used for the tests can also be adjusted as specified below:

Skipping Tests
--------------
If there is a unique line printed out in the output for jobs which are to be skipped, 
this can be used to tell testcode this, by modifying the skip_args line in the 
test_suite/userconfig file.  See the testcode documentation for more details

Adjusting Test Tolerances
-------------------------
The tolerance for an individual job can be modified as specified in the testcode documentation.
As an example, to modify the tolerance because of the following failure:
.. code-block::
    dmqmc/np1/heisenberg_1d - replica.in: **FAILED**.
    \sum\rho_{ij}M2{ji}
        ERROR: absolute error 1.00e-06 greater than 1.00e-10. (Test: 17.378583.  Benchmark: 17.378584.)

The follow section can be inserted into test_suite/jobconfig.  Note the backslash-quoting of the 
backslashes, as the tolerance value is interpreted as a python tuple containing a python string.
.. code-block::
    #Job specific tolerances:                                                                 
    [dmqmc/np1/heisenberg_1d/]                                                                
    tolerance = (1e-5,1e-5,'\\sum\\rho_{ij}M2{ji}')          


Analysing FCIQMC and iFCIQMC calculations
-----------------------------------------

FCIQMC and iFCIQMC calculations print out data from a block of iterations (a
'report loop'), the length of which is controlled by the **mc_cycles** input
option.  Care should be taken analysing this data and, in particular, producing
accurate estimates of the errors in the means of the energy estimators.

Users are encouraged to read the notes in
documentation/theory/projected_energy/proje.tex.  As the psip distribution at
one iteration is not independent from the distribution at the previous
iteration, the energy at each iteration is not independent.  This correlation in
the data needs to be taken into account when estimating standard errors.
A simple and effective way of doing this is to use a blocking analysis
[FlyvbjergPetersen89]_.

Each report loop prints out the following data:

iterations
    The number of completed iterations.
Instant shift
    The value of the shift (growth estimator, in DMC language) based upon the
    current psip distribution.
Av. shift
    The running average of the shift.  This is accumulated from the first
    iteration that the shift is allowed to vary within the current calculation
    (i.e. it is not preserved when a calculation is restarted).  As such, it
    does not exclude an equilibration period and is not always a good estimate
    of the true mean as a result.  
\sum H_0j Nj
    The numerator of the projected energy summed over the iterations in the
    report loop; the sum over the determinants connected to the reference
    determinant multiplied by the psip population on the determinant, in term
    summed over iterations in the report loop.
Av. Proj. E
    The running average of the projected energy.  This is accumulated from the 
    start of the current calculation (i.e. it is not preserved when
    a calculation is restarted).  As such, it does not exclude an
    equilibration period and is not always a good estimate of the true mean as
    a result.

    Note that the numerator and denominator are accumulated separately and the
    ratio printed out to avoid a bias caused by the ratio of means being
    different from the mean of a ratio.
# D0
    The denominator of the projected energy summed over the iterations in the
    report loop; the psip population on the reference determinant summed over
    the iterations in the report loop.
# particles
    The total psip population at the end of the report loop.
R_spawn
    The average rate of spawning for each iteration in the report loop; the
    fraction of spawning attempts which were successful.
time
    The average time each iteration took between report loops.

Note that no data is lost when quantities are summed over report loops, as the
correlation length in the data is substantially longer than the length of the
report loop (typically 20 iterations).

The running averages of the shift and projected energy can be reset using the
**zero_means** option with :ref:`HANDE.COMM`.  However, it should be
emphasised that the best estimates of the energy and associated standard error
are obtained via re-blocking the data as a post-processing step.  Often the
averaged values printed out are only adequate for (at best) monitoring
convergence and stability.  The reblock_hande.py script (in the tools subdirectory)
does this.  Run

.. code-block:: bash

    reblock_hande.py --help

to see the available options.  Estimates for the shift and projected energy are
typically obtained using

.. code-block:: bash

    reblock_hande.py --start N out

respectively, where N is the iteration from which data should be blocked (i.e.
after the calculation has equilibrated) and out is the file to which the
calculation output was saved.

Note that reblock_hande.py can accept multiple output files for the case when
a calculation is restarted.  More complicated analysis can be performed in python by
using the pyhande library (which reblock_hande is a simple wrapper around).

Plotting Calculation Output
---------------------------

The first section of the output file contains information about the basis functions
used in the calculations. This gives spurious data points when the contents of the file
is plotted using gnuplot. They can be removed by creating an executable file gphande
in the path, containing:

.. code-block:: bash

    #!/bin/sed -nf
    1,/iterations/d
    /^ *[0-9]/p

When plotting in gnuplot, using the command

    plot '<gphande file'

instead of

    plot 'file'

will then remove the extra points.

Input options
-------------

Input options are case insensitive and can be given in any order.  A new line
is required for each keyword.  Keywords are given in **bold** text.  Items
following a keyword that are in *italics* are given as input values to that
keyword.  Optional arguments are enclosed in square brackets.

With the exception of the **lattice** keyword, all values associated with
a specific keyword should appear on the same line as that keyword.

Items enclosed in parentheses are treated as comments.  All input options are
echoed in the output and so comments allow for notes on the calculation to be
made in the input which are then automatically included in the output.

The current input options allow the formulation of the Hubbard model, the
system parameters and the nature of the calculation to be given.

System type
^^^^^^^^^^^

These options select the type of system to use.

**hubbard_k**
    Default system type.

    Use the momentum space formulation of the Hubbard model.  Slater
    determinants are formed in the basis of Bloch functions :math:`\psi_k`:

    .. math::

        \psi_k(r) = e^{ik.r} \sum_i \phi_i(r)

    where :math:`\phi_i(r)` is the basis function centred on site :math:`i`.
**hubbard_momentum**
    Synonym for **hubbard_k**. 
**hubbard_real**
    Use the real space formulation of the Hubbard model.  Slater determinants
    are formed from the basis functions, :math:`\phi_i`, which are each centred
    on a lattice site.  Periodic boundary conditions are imposed through the
    kinetic 'hopping' term in the Hamiltonian.
**heisenberg**
    Perform calculation on the Heisenberg model.
    This is for a lattice of spin 1/2 particles with or without periodic
    boundary conditions imposed. The model definition in HANDE is

    .. math::

        \hat{H} = -J \sum_{\langle i,j \rangle} \hat{\boldsymbol{S}}_i \cdot \hat{\boldsymbol{S}}_j.

    It is also possible to add a magnetic field term,

    .. math::

        \hat{H} = -J \sum_{\langle i,j \rangle} \hat{\boldsymbol{S}}_i \cdot \hat{\boldsymbol{S}}_j - h_z \sum_i \hat{S}_{iz},

    or a staggered magnetic field term,

    .. math::

        \hat{H} = -J \sum_{\langle i,j \rangle} \hat{\boldsymbol{S}}_i \cdot \hat{\boldsymbol{S}}_j - h_z' \sum_i \hat{S}_{iz}^{\xi},

    where :math:`h_z` and :math:`h_z'` denote the magnetic field strength and
    staggered magnetic field strength, respectively, and :math:`\xi`
    is equal to +1 for sites on sublattice 1 and is equal to -1 for sites on
    sublattice 2. :math:`h_z` and :math:`h_z'` are set using the
    **magnetic_field** and **staggered_magnetic_field** options.
    
    Warning: for efficiency reasons it is assumed that the smallest dimension
    lattice vector is greater than 2 if periodic boundary conditions are used.
**ueg**
    Perform calculation on the uniform electron gas.

System
^^^^^^

These options describe the system which is to be investigated.

**electrons** *nel*
    Integer.

    Required for systems other than the Heisenberg model.

    Set the number of electrons in the system to be *nel*.
**lattice** *lattice vectors*
    Integer matrix.

    Required.

    Set the lattice vectors (and as a result the dimensionality) of the system.
    The lines immediately after **lattice** are assumed to be the :math:`n
    \times n` matrix containing the lattice vectors of the crystal cell (i.e.
    one lattice vector per line).  1D, 2D and 3D systems can be specified using
    vectors of the appropriate dimensionality.

    
**nel** *nel*
    Synonym for **electrons**.
**T** *t*
    Real.

    Default: 1.

    Set the kinetic term in the Hubbard Hamiltonian to be *t*, i.e. the kinetic operator (in a local/real-space orbital basis) is:

    .. math::

        \hat{T} = -t \sum_{i,j,\sigma} a_{i\sigma}^{\dagger} a_{j\sigma}.

**U** *U*
    Real.

    Default: 1.

    Set the Coulomb term in the Hubbard Hamiltonian to be *U*, i.e. the Coulomb operator (in a local/real-space orbital basis) is:

    .. math::

        \hat{U} = U \sum_i n_{i\uparrow} n_{i\downarrow}.

**J** *J*
    Real.
    
    Default: 1.
    
    Set the coupling constant for the Heisenberg model, as defined by

    .. math::

        \hat{H} = -J \sum_{\langle i,j \rangle} \hat{\boldsymbol{S}}_i \cdot \hat{\boldsymbol{S}}_j

**magnetic_field** *h_z*
    Real.
    
    Default: 0.
    
    Set the uniform external field for the Heisenberg model. The z direction is
    defined to be in the same direction as the external field. The spins in the
    basis functions point in this direction.

    The Hamiltonian for the simulation will be

    .. math::

        \hat{H} = -J \sum_{\langle i,j \rangle} \hat{\boldsymbol{S}}_i \cdot \hat{\boldsymbol{S}}_j - h_z \sum_i \hat{S}_{iz},

    where :math:`h_z` is equal to *h_z*.
**staggered_magnetic_field** *hs_z*
    Real.

    Default: 0.

    Set a staggered magnetic field for the Heisenberg model.

    The Hamiltonian for the simulation will be

    .. math::

        \hat{H} = -J \sum_{\langle i,j \rangle} \hat{\boldsymbol{S}}_i \cdot \hat{\boldsymbol{S}}_j - h_z' \sum_i \hat{S}_{iz}^{\xi},

    where :math:`h_z'` is equal to *hs_z* and where :math:`\xi` is equal to +1 for
    sites on sublattice 1 and is equal to -1 for sites on sublattice 2.

    Only valid for bipartite lattices.  Currently only one of **magnetic_field**
    and **staggered_magnetic_field** can be non-zero.
**twist** *t1 [t2 [t3]]*
    Real.

    Default: 0.0.

    Apply a twist to the wavevector grid.  The twist is an *ndim*-dimensional
    vector in units of :math:`2\pi`.  The twist angle should be within the
    first Brillouin zone, and hence the components should be between -0.5 and
    +0.5.

    Applicable only in the momentum space formulation of the Hubbard model.

**finite_cluster**
    The default behaviour for hande.x is to work on an infinite lattice
    contructed out of repeating the user-specified unit cell. If finite_cluster
    is specified then Hubbard will only work on the single unit cell and *not*
    the periodic continuation which would give us a lattice.

    Applicable only in the real-space formulation of the Hubbard model and
    Heisenberg model, otherwise the user is notified and the keyword is
    ignored.

**triangular_lattice**
    When using a rectangular lattice, this option will add extra bonds to the
    lattice so that, in terms of the connectivity of the various sites, the
    lattice will be identical to a triangular lattice. It will have the same
    smallest energy eigenvalue as the equivalent the triangular lattice.
    
    Periodic boundary conditions may only be applied to bipartite lattices.

UEG Systems
^^^^^^^^^^^

These options are only relevant for calculations on the uniform electron gas.

**2D**
    Perform calculation on the 2D UEG.
**3D**
    Perform calculation on the 3D UEG.
**density** *rs*
    Real.

    Default: 1.

    Set the density, :math:`r_s`, of the UEG to be *rs*.
**ecutoff** *emax*
    Real.

    Default: 3.

    Set the maximum kinetic energy of the orbitals included in the basis set.

    Note that this is in scaled units of :math:`(2\pi/L)^2`, where :math:`L` is the
    dimension of simulation cell defined by *nel* and *rs* and is compared to
    the kinetic energy of each plane-wave without the twist angle included.  In
    this way **ecutoff** can be kept constant when **twist** is varied and the
    basis set used will remain consistent.
**rs** *rs*
    Synonym for **density**.

Algorithm options
^^^^^^^^^^^^^^^^^

The following are modes which can be used on top of some of the calculation
types below. They are turned off by default.

**real_amplitudes**
    Allow walker amplitudes to have a non-zero fractional part.

    This will often significantly reduce the stochastic noise in the various
    Monte Carlo estimates. One should consider setting the pre-processor option
    POP_SIZE=64 when using this option as this allows a greater range of
    amplitudes to be encoded.

    This option is only implemented with the **fciqmc**, **ccmc** and **dmqmc**
    options currently.
**spawn_cutoff** *cutoff*
    Real.

    Default when using **real_amplitudes**: 0.01.
    Default otherwise: 0.0.

    Set the minimum absolute value for the amplitude of a spawning event. If a
    smaller spawn occurs then its amplitude will probabilistically be rounded up
    to *cutoff* or down to zero in an unbiased manner.

    This parameter is relevant when using the **real_amplitudes** option. When
    not using the **real_amplitudes** option, all spawning occurs in multiples
    of 1.
**semi_stoch_high_pop** *space_size*
    Perform a semi-stochastic calculation. The deterministic space is created
    by choosing the *space_size* most populated determinants in the simulation.
    If there are less than *space_size* determinants in the simulation then all
    determinants will be used in the deterministic space.

    If the **semi_stoch_iteration** option is used then this option will use
    the walker configuration at the specified iteration, else the deterministic
    space will be created using the determinants present before the start of
    the first iteration. Therefore, one should only use this option in
    conjuction with the **restart** option or with the **semi_stoch_iteration**
    option.

    This option is only implemented with the **fciqmc** method.

    If this option is used then the **real_amplitudes** option will be turned on
    automatically.
**semi_stoch_read**
    Perform a semi-stochastic calculation. The deterministic space is created
    by reading in determinants from an HDF5 file produced using the
    **write_determ_space** option.
**semi_stoch_iteration** *iter*
    Turn the semi-stochastic algorithm on at iteration number *iter*.
**semi_stoch_shift_start** *iter*
    Turn the semi-stochastic algorithm on *iter* iterations after the shift
    starts to vary.
**semi_stoch_combine_annihil**
    Default: false.

    This option will allow the semi-stochastic method to be used without an
    extra MPI call per iteration. Instead, deterministic spawnings are added to
    the spawned list and communicated with all other spawnings. One may find
    large variations in the time to perform each iteration, depending on
    whether this option is used or not.

Calculation type
^^^^^^^^^^^^^^^^

The following options select which kind of calculation(s) are performed on the
chosen system.  If no calculation type is given, then only the calculation
initialisation (mainly the enumeration of the basis) is performed.

Note that multiple calculations can be specified within a single input, but are performed in a set order.  Specifying **fciqmc** and **ifciqmc** is unlikely to work though!

**exact**
    Perform a full diagonalisation of the Hamiltonian matrix.
**fci**
    Synonym for **exact**.
**simple_fciqmc**
    Perform an FCIQMC calculation using an extremely simple (but wasteful, in
    terms of CPU and memory resources) algorithm.  This should be used for testing only.
**fciqmc**
    Perform an FCIQMC calculation [BoothThomAlavi09]_.
**dmqmc**
    Perform a Density Matrix Quantum Monte Carlo (DMQMC) calculation.
**ifciqmc**
    Perform an initiator-FCIQMC calculation [ClelandBoothAlavi10]_.
**ct_fciqmc**
    Perform a continuous-time FCIQMC calculation.
**lanczos**
    Perform a Lanczos diagonalisation of the Hamiltonian matrix.
**lanczos_direct**
    Perform a Lanczos diagonalisation of the Hamiltonian matrix but calculate
    the required Hamiltonian matrix elements on the fly rather than
    pre-computing the entire Hamiltonian matrix (as is done with **lanczos**).
    This is slower but requires much less memory.  This is currently only
    implemented in serial.
**estimate_hilbert_space** *ncycles*
    Integer.

    Estimate the size of the Hilbert space within the desired symmetry block of
    the Hamiltonian by performing *ncycles* cycles of a Monte Carlo algorithm.
    The overall spin must be set using **ms**.
    Appropriate spatial and momentum symmetries are taken into account.
    The symmetry block can be selected by specifying a reference determinant.
    When run on multiple processors, an estimate of the error in the size is produced.
    This is not available on a single processor, and the user is warned to test the
    value by changing seeds or number of cycles, as not all printed figures may be significant.

    For the real space formulation of the Hubbard model and the Heisenberg
    model, the exact size of the space (at least to the first 8 significant
    figures) is found by simple combinatorics.

**estimate_canonical_kinetic_energy**

    Estimate the free-electron thermal kinetic energy in the canonical ensemble
    in all momentum symmetry sectors by performing nkinetic_cycles*init_pop cycles of a
    Monte Carlo algorithm. Also estimate <H>_0, which is a form of Hartree-Fock energy.
    Estimates for mean and variance are printed out every init_pop cycles.

Calculation options: symmetry options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

FCI calculations consider the full Hamiltonian matrix.  This is automatically
constructed in a block diagonal form via the use of symmetry, allowing for the
Hamiltonian matrix to be considered a block at a time.  This results in
a substantial reduction in CPU and memory demands.  The default behaviour is to
diagonalise all blocks of the Hamiltonian matrix but this can be controlled by
the following options.

In contrast, an FCIQMC calculation can only consider a single block of the
Hamiltonian matrix.  The spin polarisation must be specified and the symmetry
of the determinant is currently hard-coded.

**ms** *ms*
    Integer.

    Diagonalise only blocks containing determinants with the specified value of Ms,
    in units of electron spin (i.e. 1/2).
    
    For the Heisenberg model, ms is applied in a similar manner. Here, each site is
    either spin up or spin down, so ms = #spins_up - #spins_down, the total spin
    in the block considered.
**symmetry** *isym*
    Integer.
    
    This does not apply to the Heisenberg model.

    For the momentum space formulation:  Diagonalise only blocks
    containing determinants of the same symmetry as the specified symmetry
    block *isym*.  *isym* refers to a wavevector label (as given in the
    output).  To see the symmetry labels for a specific crystal cell, run the
    calculation without any calculation type specified.  The :math:`\Gamma`
    wavevector is always given by *isym*:math:`=1` if *t* is positive and by
    the number of sites in the cell if *t* is negative.

    For point group symmetries in molecular systems: This specifies the symmetry of the
    wavefunction, and is zero-based, with 0 being the totally symmetric irrep.  The other
    symmetries correspond to those from the FCIDUMP (after subtracting 1 from the index).

    If the FCIDUMP contains Lz symmetry, this is also used, but cannot currently
    be specified, so the Lz=0 sector is chosen by default.
**sym** *isym*
    Synonym for **symmetry**.
**lz**
    Specify if Lz symmetry is to be used.  Currently can only look at the Lz=0 block.
    For more information see the **Lz Symmetry** section.

Calculation options: diagonalisation options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These options are only valid when a diagonalisation (either full or Lanczos)
calculation is performed.  The eigenvectors are only calculated if required (i.e.
**print_fci_wfn** or **analyse_fci_wfn** is positive), as doing so is much slower.

**print_fci_wfn** *nwfn* *wfn_file*
    Optional integer, default: -1.  Optional string, default: FCI_WFN.

    Print out the first *nwfn* FCI wavefunctions from each spin and symmetry block.
    If nwfn is negative (default) then all wavefunctions are printed out.  The
    wavefunctions are printed to *wfn_file* (defaults to FCI_WFN).
**analyse_fci_wfn** *nwfn*
    Optional integer, default: -1.

    Calculate properties of the first *nwfn* FCI wavefunctions from each spin and
    symmetry block.  If nwfn is negative (default) then all wavefunctions are
    analysed.  This is slow, and uses a very simple algorithm.  It is only
    designed for debugging purposes.  The properties evaluated depend upon the system
    and are liable to change without warning.

Calculation options: Lanczos options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These options are only valid when a Lanczos diagonalisation calculation is
performed.

**lanczos_basis** *nbasis*
    Integer.

    Default: 40.

    Set the number of Lanczos vectors to be used.  This determines the main
    memory requirements of the Lanczos routine.  The size of the basis can have
    an impact on the performance of the Lanczos diagonalisation and which
    excited eigensolutions are found.  See the TRLan documentation,
    http://crd.lbl.gov/~kewu/ps/trlan\_.html, for more details.
**lanczos_solutions** *nsolns*
    Integer.

    Default: 5.  

    Set the number of eigenvalues (and eigenvectors, if required) to be found
    via Lanczos diagonlisation.  The Hamiltonian matrix is constructed in block
    diagonal form using spin and crystal momentum conservation rules.  nsolns
    is the number of solutions found per block.
**lanczos_solns** *nsolns*
    Synonym for **lanczos_solutions**.

Calculation options: FCIQMC options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following options are valid for FCIQMC calculations.

**mc_cycles** *mc_cycles*
    Integer.

    Number of Monte Carlo cycles to perform per "report loop".

    Note that *mc_cycles* is set to be 1 for the continuous time algorithm.
**nreports** *nreports*
    Integer.

    Number of "report loops" to perform.  Each report loop consists of 
    *mc_cycles* cycles of the FCIQMC algorithm followed by updating the shift
    and output of information on the current state of the walker populations, in
    particular the instantaneous energy estimators.

    If *nreports* is set to be a negative number, then the FCIQMC algorithm
    will effectively loop indefinitely (strictly speaking: *nreports* is set to
    the largest possible number that can be held in the standard integer type).
    In such cases calculations should be cleanly exited using the
    :ref:`HANDE.COMM` functionality.

    The total number of Monte Carlo cycles performed in an FCIQMC calculation
    is *nreports* x *mc_cycles*.
**seed** *seed*
    Integer.

    Default: random value based upon a hash of the time and (if available) the
    universally unique identifier (UUID) of the calculation.

    Set the seed used to initialise the dSFMT random number generator.
    In parallel the seed on each processor is *seed* + iproc, where iproc is
    the processor index (as supplied by MPI) and ranges from 0 to nprocs-1.
**tau** *tau*
    Real.

    Set the timestep to be used.  Each Monte Carlo cycle amounts to propagating
    the walker population by the *tau* in units of imaginary time.

    A small timestep causes the walker population to evolve very slowly.  Too
    large a timestep, on the other hand, leads to a rapid particle growth which
    takes a long time to stabilise, even once the shift begins to vary, and
    coarse population dynamics.
**tau_search**
    Update the **tau** automatically by scaling it by 0.95 if a bloom event is
    detected.  A bloom event is defined as one which spawns more than three
    particles in a single spawning event in FCIQMC and one which spawns more than 5% of
    the total current population in a single spawning event in CCMC.

    .. note::

        This is an experimental option and feedback on required flexibility or
        alternative approaches is most welcome.

        **tau_search** is currently ignored in DMQMC calculations.

**initial_shift** *initial_shift*
    Real.

    Default: 0.

    Set the value of the shift to use during the period before the shift is
    allowed to vary.  Positive values lead to faster growth in the number of
    walkers due to cloning.  Using too large a value can lead to poor sampling
    as large numbers of walkers reside on the same small number of determinants
    rather than diffusing appropriately through the determinant space.
**vary_shift_from** **proje** | *shift* 
    String or real.

    Default: off.

    Set the shift to be either the instantaneous projected energy or the value
    specified by *shift* when *varyshift_target* is reached.  Most calculations
    start with setting the shift to be 0; by instantly setting the shift to
    a value closer to the true ground state, the simulation can stabilise the
    total walker population substantially faster.

    Note that the last option out of **initial_shift** or **vary_shift_from**
    *shift* is used.  Only use both options if you know what you're doing.

    There is no guarantee that the instantaneous projected energy is a good
    estimate of the ground state (particularly in the real-space formulation of
    the Hubbard model), but it is likely to be closer to it than the default
    shift value of 0.
**varyshift_target** *varyshift_target*
    Long integer.

    Default: 10000.

    Set the target number of particles to be reached before the shift is
    allowed to vary.  This is only checked at the end of each report loop.
**shift_damping** *xi*
    Real.

    Default: 0.05.

    Once the *varyshift_target* has been reached, the shift is updated according to:

    .. math::

        S(\beta) = S(\beta-A\tau) - \frac{\xi}{A\tau} log\left( \frac{N_w(\tau)} {N_w(\beta-A\tau)} \right)

    where :math:`\beta` is the current imaginary time, :math:`A\tau` is the
    amount of imaginary time between shift updates, :math:`N_w` is the number of
    walkers at the given time and :math:`\xi` is a damping factor to prevent
    wild fluctuations in the population dynamics and can be set using the
    **shift_damping** keyword.
**reference_det** *electron_1 electron_2 ... electron_nel*
    Integer list.

    Default: Momentum-space formulation of the Hubbard model
    Uses the Hartree--Fock determinant (ie that formed from occupying the
    nalpha and nbeta spin-orbitals with the lowest kinetic energy); 

    Default: Real-space formulation of the Hubbard model
    Attempt to minimise the number of doubly-occupied sites.  
    Note that this is not guaranteed (especially in the
    real-space formulation) to give a reference determinant which is close to
    the ground state.  Further, the default ignores any value of
    the symmetry as defined by the **sym** input option.
    
    Default: Heisenberg model
    For ferromagnetic cases (J>0) the default will attempt to group the up
    spins together, which often will result in the best reference determinant.
    For antiferromagnetic cases, first it will attempt to choose sites
    which do not neighbour each other. Then, if more spins are required
    it will choose the remaining spins in order of site label.
    This will usually give a good reference determinant, but it is not guaranteed
    always. For bipartite lattices however, the antiferromagnetic determinant 
    chosen should be the best one possible.
    
    Set the reference determinant to occupy the specified spin-orbitals.
    The index of each spin-orbital is printed out in the basis functions
    section of the output.  This will be overridden by a restart file and
    in a simple_fciqmc calculation, where the determinant with the lowest
    energy is set to the reference determinant.
    
    For the Heisenberg model, the electron positions will actually represent the
    positions on the lattice of the up spins in the reference basis vector.
    (Note that the number of up spins is deduced from the ms value specified and the
    total number of sites).
**init_pop** *pop*
    Integer.

    Default: 10.

    Set the initial walker population on the reference determinant.  This will
    be overridden by a restart file.

    For DMQMC calculations this option sets the number of psips which will
    be randomly distributed along the diagonal at the start of each beta loop.
**cluster_multispawn_threshold** *thresh*
    real.
    
    Default: huge  (i.e. off).

    When selecting clusters the generations probabilities can vary over orders of
    magnitude.  If after having selected the cluster, the value of
    cluster%amplitude/cluster%pselect
    is greater than *thresh*, then the number of spawning attempts from that cluster,
    nspawn_attempts, will be set to the smallest number such that
    cluster%amplitude/(cluster%pselect*nspawn_attempts) is less than *thresh*.
    The overall effect will be to reduce population blooms which raise plateau heights.
    The lower this number is the slower a calculation will be, though a larger tau might
    be able to be used.
    To enable, set to a number such as 0.1.
    NB the probability that the spawning is successful is still also dependent on 
    tau*(the spawning matrix element)/(the probability of generating the spawning excitation),
    and so estimates of these might be able to be used to set sensible values of *thresh*.

**init_spin_inverse_reference_det**
    Default: false.

    In addition to initialsing the reference determinant with an initial
    population, initialise the spin-inversed determinant (if different) with
    the same population.  This will be overridden by a restart file.
**select_reference_det** [*N* [*pop_fac*]]
    Default: off, 20 and 1.5.

    This option is only available when using the *fciqmc* method.

    Set the reference determinant to be the determinant with the largest
    population every *N* cycles if that population is greater than the
    population on the current reference determinant by a factor larger than
    *pop_fac*.  *pop_fac* should be greater than 1 to avoid repeated switching
    between degenerate determinants.

    .. warning::

        Care must be taken with averaging quantities when using this option.
        In particular, one should only average the projected estimator over
        imaginary time during which the reference determinant is constant.

**walker_length** *walker_length* [**MB**]
    Integer.

    Size of walker array.  This is allocated at the start of the calculation
    and is used to store the population of walkers on determinants with
    a non-zero population and the associated energy of the determinant.

    If **MB** is specified, then the walker_length is given in terms of MB per
    core rather than number of elements per core in each array
    associated with the parent walkers.

    Care: this needs to be large enough to hold the number of unique
    determinants with a non-zero population of walkers in the simulation.  The
    code does not currently check whether this size is exceeded and so setting
    **walker_length** to be too small can lead to memory problems and
    segmentation faults.  For large calculations this should be substantial
    smaller than the full size of determinant space.

    Not valid for simple_fciqmc calculations, where the population of walkers
    on each determinant is stored.
**spawned_walker_length** *spawned_walker_length* [**MB**]
    Integer.

    Size of the spawned walker array.  This is allocated at the start of the
    calculation and is used to store the population of spawned walkers on child
    determinants.

    If **MB** is specified, then the spawned_walker_length is given in terms of
    MB per core rather than number of elements per core in each array
    associated with the spawned walkers.

    Care: this needs to be large enough to store all the particles which are spawned
    during a Monte Carlo cycle and so needs to be a reasonable fraction of the 
    targeted number of total number of walkers.  The code does not currently
    check whether this size is exceeded and so setting
    **spawned_walker_length** to be too small can lead to memory problems and
    segmentation faults.

    Not valid for simple_fciqmc calculations, where the population of spawned
    walkers on each determinant is stored.
**no_renorm**
    Default (uniform electron gas): On.

    Default (all other systems): Off.

    Generate (and then reject) excitations which involve exciting an electron
    into a spin-orbital which is already occupied.  Whilst this is wasteful, it
    avoids having to renormalise the excitation generation probabilities, which
    can be expensive for large systems.
**dump_restart** [**shift**]  [*id*]
    Optional integer.

    Write out information required for restarting an FCIQMC calculation to
    a file called HANDE.RS.x.py.H5, where x is *id* if *id* is given and y is 
    the processor rank. If x is not given, it is chosen to be the smallest 
    integer possible such that HANDE.RS.x.py.H5 does not exist in the
    calculation directory.

    If **shift** is specified, then the restart information is dumped out before
    the shift turns on. Both dump_restart and dump_restart shift may be specified
    in the input file but the optional *id* (if specified) for both must be different.

    Restarting a parallel run with a different number of processors is not 
    currently supported.

    Warning: these files can become very large, so care should be taken when
    not re-using the same filenames.
**dump_restart_every** *nreport*
    Integer.  Default: off.

    Write out a restart file every *nreport* report cycles.

    .. warning::

         Unless **dump_restart** is specified with a file id, this will create
         a new restart file every *nreport* report cycles.  The disk space used
         with this option can therefore be very large.  Small values of
         *nreport* should only be used for diagnostic purposes and not in
         production calculations on large systems.

         Furthermore, writing to (for instance) a network disk will degrade performance
         substantially.

**write_determ_space**
    Default: off.

    Write the determinants in any used semi-stochastic deterministic space to a
    file. This is done for each deterministic space used, to a separate file
    each time.
**ascii_format_out**
    The default format for restart files is binary, as for the most part the files
    are meant purely for reading by Hubbard, and having the file in human-readable
    ASCII format is both wasteful of space and unnecessary. 

    If the **ascii_format_out** keyword is specified, however, this overrides the default
    and the restart file is written out in ASCII. Beware; these files can become
    very large.
**ascii_format_in**
    Similar behaviour to **ascii_format_out** except that this one specifies that the restart
    file to be read (specified with the **restart** keyword) is in non-standard ASCII format
    as opposed to binary format.
**ascii_format**
    An Alias for both **ascii_format_in** and **ascii_format_out**
**restart** [*id*]
    Optional integer.

    Restart an FCIQMC calculation using a previous restart file,
    HANDE.RS.x.py.H5, where x is a non-negative integer and y is the processor
    rank. If *id* is given, x is set to *id*; otherwise x is chosen to be the
    largest integer such that HANDE.RS.x.py.H5 exists and HANDE.RS.x+1.py.H5
    does not.

    The restart file does not contain system information such as the U and
    T parameter, lattice vectors, number of electrons or if the walker
    population were evolved using standard FCIQMC or initiator-FCIQMC. Thus it
    is important use the same system parameters when restarting a calculation.
    The consistency of the restart file with the input options supplied is not
    checked.
    
    Please note that the RNG is not stored in the restart file, so running two
    shorter calculations via the restart facility is not completely identical
    to running a single calculation for the same number of Monte Carlo cycles.

    Furthermore, the current implementation does not allow restart files
    produced with one value of DET_SIZE to be used with binaries produced with
    a different value of DET_SIZE.  However, this is not checked!
**uniform_combination**
    For the Heisenberg model only. If this keyword is specified then instead of using a
    single reference detereminant to calculate the projected energy, a linear combination
    of all basis functions with amplitudes 1 is used:

    .. math::

    	|\psi \rangle = \sum_{i} |D_i \rangle

    hence the estimator used is


    .. math::

        E_0 = \frac{ \langle \psi|H|\psi_0 \rangle }{ \langle \psi|\psi_0 \rangle }
            = \frac{ \sum_{i,j} \langle D_i|H|D_j \rangle c_j } { \sum_{i} c_i }
                  
    A unitary transformation will be applied to the Hamiltonian so that all the
    off-diagonal elements are multiplied by -1. This has the effect of making
    the transformed ground state have all positive components, and hence the above
    trial function has a large overlap with this transformed ground state.
    
    This can only be used for bipartite lattices.
**neel_singlet_estimator**
    For the Heisenberg model only. If this keyword is specified then instead of
    using a single reference detereminant to calculate the projected energy,
    the Neel singlet state is used. This is a state,
    :math:`|NS \rangle = \sum_{i} a_i |D_i \rangle`, where the amplitudes
    :math:`a_i` are defined in K. Runge, Phys. Rev. B 45, 7229 (1992). For
    further details, see the comments in the subroutine
    update_proj_energy_heisenberg_neel_singlet in heisenberg_estimator.F90.
    
    This can only be used for bipartite lattices.
**neel_singlet_guiding**
    For the Heisenberg model only. If this keyword is specified then the Neel
    singlet state is used as a guiding state for importance sampling. This
    means that the the matrix elements of the Hamiltonian, :math:`H_{ij}`, are
    replaced by new components

    .. math::
    
        H_{ij} \leftarrow (a_i H_{ij})/a_j
    
    where :math:`a_i` is a component of the Neel state, as specified above.
    
    When this guiding function is used, the Neel singlet must be used in the
    projected energy, so the neel_singlet_estimator option is automatically
    applied.

Calculation options: CCMC options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**move_freq** [x]
    Optional integer.  Default: 5.

    Excitors are allowed to move processors every 2^x iterations in order to
    allow all composite excitors to be correctly sampled.  Relevant only when
    performing CCMC calculations with multiple MPI processes.

**ccmc_full_nc**
    Default: off.

    The original CCMC algorithm involves randomly selected a cluster of arbitrary size
    consisting of any set of excitors and then making spawning attempts from it.
    The full non-composite algorithm is a simple modification in which all occupied
    non-composite clusters (i.e. those consisting of the reference or just a single
    excitor) are (deterministically) selected and composite clusters (involving two or
    more excitors) are randomly selected to make spawning attempts.  This has been shown
    to give substantially more stable dynamics and reduce the plateau height in
    several systems.

**ccmc_linked**
    Default: off

    The original CCMC algorithm solves the equations

    .. math::

        \langle D_m | \hat{H} - E | \psi_{CC} \rangle = 0.

    It is possible to instead sample the equivalent equations

    .. math::

        \langle D_m | e^{-\hat{T}} (\hat{H} - E) | \psi_{CC} \rangle = 0.

    Using the Hausdorff expansion of the Hamiltonian and the linked cluster theorem means 
    that the only clusters which contribute are those with at most four excitors and where 
    the exitation sampled from the Hamiltonian has an orbital in common with each excitor 
    in the cluster operator. Using this option can give substantial reductions in the 
    plateau height.

Calculation options: DMQMC options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In addition to the options for FCIQMC calculations, the following options are additional to the 
configuration of a Density Matrix Quantum Monte Carlo (DMQMC) calculation

Note: The DMQMC features have only been coded and tested for the Heisenberg model.

**beta_loops**
    Integer.

    Default: 100.

    Set the number of beta loops. This is the number of times that the complete range of beta values
    will be looped over before the simulation finishes.
**dmqmc_energy**
    Calculate the thermal expectation value of the Hamiltonian operator.

    This value will be calculated from the first iteration of each report loop.
**dmqmc_energy_squared**
    Calculate the thermal expectation value of the Hamiltonian squared operator.

    This value will be calculated from the first iteration of each report loop.
**dmqmc_staggered_magnetisation**
    Calculate the thermal expectation value of the staggered magnetisation operator.

    This value will be calculated from the first iteration of each report loop.

    This option is only available for bipartite lattices.
**dmqmc_correlation_function** *site_1* *site_2*
    Integers.

    Calculate the spin-spin correlation function between the two lattice sites *site_1* and
    *site_2*, defined as the thermal expectation value of the following operator:

    .. math::

    	\hat{C}_{ij} = S_{xi}S_{xj} + S_{yi}S_{yj} + S_{zi}S_{zj}.

    This value will be calculated from the first iteration of each report loop.

    Note: the correlation function can only be calculated for one pair of spins in a single simulation.
**dmqmc_full_renyi_2**
    Calculate the Renyi-2 entropy of the entire system.

    This option must only be used when the **replica_tricks** option is also used.

    The quantity output in the column 'Full S2' is the instantaneous estimate of
    :math:`\sum_{ij}\rho_{ij}^2`. The traces of the two replicas are in the columns
    named 'Trace' and 'Trace 2'. The finite_temp_analysis.py script in the tools
    directory can then be used to obtain a final temperature-dependent estimate of
    the Renyi-2 entropy from these quantities.
**truncation_level** *truncation_level*
    Integer.

    Consider only elements of the density matrix where the determinants differ
    by at most *truncation_level* excitations.
**half_density_matrix**
    Symmetrise the density matrix explicitly. This may slightly improve the efficiency
    of the algorithm in some situations.
**output_excitation_distribution**
    Output the fraction of psips on each excitation level.
**use_all_sym_sectors**
    Run a DMQMC calculation in all symmetry sectors simultaneously. Psips will be
    distributed across all symmetry sectors for the initial density matrix.
**use_all_spin_sectors**
    Run a DMQMC calculation in all spin symmetry sectors simultaneously. Psips will be
    distributed across all spin symmetry sectors for the initial density matrix.
**dmqmc_weighted_sampling** *number_weights* Integer.
                            *w_{01} w_{12} ... w_{n-1,n}* Real list.

    This option will allow a form of importance sampling to be applied to the DMQMC calculation.

    The values of :math:`w_{01}, \ldots, w_{n-1,n}` will define weights which alter the spawning probabilities
    between the various excitation levels. When attempting to spawn from an excitation level
    i to a different excitation level j, the spawning probability will be altered by a factor
    :math:`1/w_{ij}`. Also, :math:`w_{ji} = 1/w_{ij}`. This can be used to help keep psips near the diagonal elements
    and hence improve the quality of sampling when calculating estimators, which typically depend upon
    psips on the diagonal and first one or two excitation levels. This is particularly useful for larger
    lattices where typically no psips will reside on the diagonal elements when the ground state is
    reached.

    To account for the altered spawning probabilities, different weights are given to different
    psips when calculating estimators, such that the same mean values are estimated, but with an
    improved quality of sampling.

    The value *number_weights* must equal the number of weights which have been specified.
    The weights :math:`w_{01}, \ldots, w_{n-1,n}` should be input on the lines directly after
    **dmqmc_weighted_sampling**, and can be input over as many lines as required.
**dmqmc_vary_weights** *N*
    Integer.

    If this option is specified then the importance sampling procedure used with the
    dmqmc_weighted_sampling is applied with weights which are introduced gradually. The weights
    :math:`w_{01}, \ldots, w_{n-1,n}` are altered, from 1 initially, by a factor of :math:`w^{1/N}` at
    the end of each Monte Carlo cycle, so that after N cycles the weights will have reached the values
    specified. They are then held constant until the end of the beta loop, at which point they are
    reset to 1.

    This helps psips to diffuse more appropriately initially.
**dmqmc_find_weights**
    Run a simulation to attempt to find appropriate weights for use in the DMQMC importance sampling
    procedure. This algorithm will attempt to find weights such that the population of psips is
    evenly distributed among the various excitation levels when the ground state is reached (at large
    beta values). The algorithm should be run for several beta loops until the weights settle down to a
    roughly constant value.

    This option should be used with **start_averaging**, to specify when the ground state
    has been reached.

    Warning: This feature is found to be unsuccessful for some larger lattices (for example, 6x6x6).
    The weights output should be checked. Increasing the number of psips used may improve the weights
    calculated.

    The weights are output at the end of each beta loop, in a form which can be copied directly into
    the input file.
**reduced_density_matrix** *nrdm* Integer.
                           *site_1 site_2 ... site_n* Integer list.

    Option to specify which reduced density matrices (RDMs) to obtain results for.
    
    *nrdm* specifies the number of RDMs which will be calculated. Then, on the next *nrdm* lines,
    a list of the sites making up the subsystem(s) to study should be given.

    With this option, one of the two options **ground_state_rdm** or **instantaneous_rdm** should
    also be used. Both options cannot be used together. Only one RDM may be considered (*nrdm*
    must be equal to 1) when using the **ground_state_rdm** option. Moreover, when using the
    **ground_state_rdm** option, the subsystem specified should be at most half the size of the
    system (which will always be sufficient for ground-state calculations).
**ground_state_rdm**
    For the subsystem specified with the **reduced_density_matrix** option, only accumulate the
    RDM when the ground state is reached. This is specified by the user using the
    **start_averaging** option. For each beta loop, the RDM will be averaged from this first
    iterations until the end of the beta loop. Results will then be output before the next loop
    is started.
**instantaneous_rdm**
    For the subsystem(s) specified with the **reduced_density_matrix** option, calculate the RDM(s)
    from the instantaneous psip distribution. This is done on the first iteration of every
    report loop.

    Results will only be output if using an option which makes use of these instantaneous RDM
    estimates, for example, **renyi_entropy_2**.
**output_rdm**
    Only available with the **ground_state_rdm** option.

    At the end of each beta loop, output the ground-state RDM accumulated to a file. This
    file will contain the RDM trace on the first line, followed by all RDM elements above and
    including the diagonal (labelled by their index).
**start_averaging** *N*
    Integer.

    If this option is specified then averaging of the ground-state reduced density matrix only begins at Monte
    Carlo cycle *N*. Hence, when only ground state properties are desired, the cycle at which the ground
    state is deemed to have been reached should be decided, and averaging should be started from this point.
    Thus, this feature should be used when calculating values which depend on the ground-state reduced
    density matrix (using **ground_state_rdm**).

    Futhermore, this option should also used when using **dmqmc_find_weights**, again, to specify
    when the ground state is reached.
**renyi_entropy_2**
    For all the subsystems specified with the **reduced_density_matrix** option, calculate the
    Renyi-2 entropy.

    The quantity output in the 'RDM(n) S2' columns is the instantaneous estimate of
    :math:`\sum_{ij}(\rho^n_{ij})^2`, where :math:`\rho^n` is the reduced density
    matrix for the nth subsystem specified by the user. The traces of the two replicas
    are in the columns named 'RDM(n) Trace 1' and 'RDM(n) Trace 2'. The finite_temp_analysis.py
    script in the tools directory can then be used to obtain a final temperature-dependent
    estimate of the Renyi-2 entropy from these quantities.

    This option cannot be used with **ground_state_rdm**.
**concurrence**
    At the end of each beta loop, the unnormalised concurrence and the trace of the reduced density matrix
    are output. The concurrence can then be calculated by running the average_entropy.py script in the tools
    subdirectory.

    This option should be used with the **ground_state_rdm** option. Temperature-dependent concurrence is
    not implemented in HANDE.
**von_neumann_entropy**
    At the end of each beta loop, the unnormalised von Neumann entropy and the trace of the reduced density matrix
    are output. The von Neumann entropy can then be calculated by running the average_entropy.py script in the tools
    subdirectory.

    This option should be used with the **ground_state_rdm** option. Temperature-dependent von Neumann entropy
    is not implemented in HANDE.
**exact_rdm_eigenvalues**
    When performing an **exact** calculaton, using this option will cause the eigenvalues of the RDM specified
    with the **reduced_density_matrix** option to be calculated and output.

    Note that the **ground_state_rdm** option must also be used. RDM eigenvalues can only be calculated for
    one subsystem in one simulation.

    The **use_all_sym_sectors** option is not implemented with **exact** calculations, and so cannot be used
    here.
**propagate_to_beta**
    Default False.

    Propagate a particular trial density matrix to a specific value of :math:`\beta` so that in the last step we are sampling the
    actual density matrix at this :math:`\beta`.
    To see this consider the function

    .. math::

        f(\tau) = \rho^{T}(\beta-\tau)\rho(\tau),

    where :math:`\rho^{T}` is a "trial" density matrix and :math:`\rho` is our usual density matrix.
    Note that

    .. math::

        f(0) = \rho^{T}(\beta) \rho(0) = \rho^{T}(\beta)

    and

    .. math::

        f(\tau=\beta) = \rho(\beta).

    Thus by propagating :math:`f` using the (appropriately modified) DMQMC algorithm we can sample the density matrix at a particular beta.
    This removes the difficulty of sampling the infinite temperature density matrix for systems with strong reference components, as typically
    the reference will be highly populated in the trial density matrix at any :math:`\beta > 0`.
    Currently only implemented for the UEG and k-space Hubbard model.
**init_beta** *beta*
    Real.

    Beta value the (trial) density matrix will initially be sampled at when using propagate_to_beta option.
    When analysing observables using the finite_temp_analysis.py script it is only this temperature value
    which has any meaning (in terms of averages with respect to the thermal density matrix) and is the last
    iteration in the simulation.
**metropolis_attempts** *nattempts*
    Integer.

    Default 0.

    Number of metropolis iterations per psip to be carried out when attempting to sample a trial density matrix.
**max_metropolis_moves** *max_move*
    Integer.

    Default: 2.

    A metropolis move is defined as a nfold excitation of the determiant under consideration.
    max_metropolis_move gives the maximum n considered in that nfold excitation.
**free_electron_trial**
    Default use "Hartree-Fock" trial density matrix.

    Use the non-interacting Hamiltonian in our trial density matrix. This is not as efficient as the default "Hartree-Fock" density matrix.
    If using the grand_canonical_intialisation option then metropolis_attempts can be set to zero as the canonical free-electron trial density
    matrix is already being sampled.
**grand_canonical_initialisation**
    Default False.

    Use the grand canonical partition function to guide the initialisation of the trial density matrix.
    This is usually a good starting point for the Metropolis algorithm and *is* also the starting point when using the free-electron trial
    density matrix.
**chem_pot** *chemical potential*
    Real.

    Chemical potential to be used to initialise the density matrix in the grand canonical ensemble. This can be calculated using chem_pot.py in tools/dmqmc/.
    If using the free-electron trial density matrix this chemical potential will produce the correct single particle occupancies, :math:`p_i`, so that the probability of occupying
    a given determinant is given by

    .. math::

        p(i_1, i_2, \dots, i_N) = \prod_i^N p_i,

    where,

    .. math::
        p_i = \frac{1}{e^{\beta (\varepsilon_i - \mu)} + 1}

    is the usual Fermi factor.
**fermi_temperature**
    Default: False.

    Rescale time step to be a multiple of :math:`1/T_F`, where :math:`T_F = E_F/k_B` is the Fermi Temperature, :math:`E_F` is the Fermi energy and :math:`k_B` is the Boltzman constant.
    This allows results to be output in terms of :math:`\Theta=T/T_F` which a useful quantity when comparing energy scales.

Calculation options: initiator-FCIQMC options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In addition to the options for general FCIQMC calculations, the following
options are also valid in initiator-FCIQMC calculations:

**initiator_population** *population*
    Integer.

    Default: 3.

    Set the (unsigned) population at which a determinant is considered to be an
    initiator determinant.  Setting this value to 0 retrieves the FCIQMC
    result.

Calculation options: parallel options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These options control the behaviour when run in parallel.  They do not affect
the result but can have a significant impact on performance.

**block_size** *block_size*
    Integer.

    Default: 64.

    Set the block size used to distribute the Hamiltonian matrix across the
    processors.  The Hamiltonian matrix is divided into :math:`n \times n`
    sub-matrices, where :math:`n` is the block size, which are the distributed
    over the processors in a cyclic fashion.  Applicable only to FCI
    calculations.
**doing_load_balancing**
    Attempt to dynamically modify the hashing of determinants to processors
    so as to get a more even distribution of walkers across processors.
    See top-level comments in load_balancing.F90 for details.
**load_balancing_slots**
    Integer.

    Default: 20.

    Set the number of slots the walker list hash range is divided into.
    proc_map then contains N_p*load_balancing_slots number of slots.
    Setting this to too large a value will affect performance but could
    potentially result in a better distribution of walkers.
**load_balancing_pop**
    Long integer.

    Default 1000.

    Attempt to perform load balancing after the total number of walkers
    across processors is greater than load_balancing_pop. This is a
    system dependent variable and should be set so that the population
    is roughly stable at this value.
**percent_imbal**
    Real.

    Default 0.05.

    Desired percentage imbalance between the most/least populated processor
    and the average population. So, min_pop ~ (1-percent_imbal)*av_pop and
    max_pop ~ (1+percent_imbal)*av_pop.
**max_load_attempts**
    Integer.

    Default 2.

    Load balancing will be attempted once per report loop until max_load_attempts
    is reached.
**write_load_info**
    Default: false.

    Write out the population of the most and least heavily populated processor
    before and after load balancing is carried out. Also print out the
    minimum slot population on the most populated processor which will
    indicate if load balancing is possible.

**use_mpi_barriers**
    Default: false.

    Perform MPI_Barrier calls before the main MPI communication calls (both
    for communication of the spawned list, and any semi-stochastic
    communication). These are timed, and the total time spent in these calls
    is output at the end of a simulation. This option is useful for assessing
    issues in load balancing, as it will allow you to see when certain
    processors take longer to perform their work than others. This is turned
    off by default because such calls may have an initialisation time which
    scales badly to many processors.


Calculation options: estimate canonical kinetic energy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    **nkinetic_cycles**
    Integer.

    Default 1.

    Perform nkinetic_cycles * init_pop Mote Carlo iterations for estimating the
    canonical kinetic energy.

Output options
^^^^^^^^^^^^^^

These options increase the verbosity but can be useful for debugging.  Note that
the file sizes scale factorially with system size.  These should not currently
be used in parallel.

**determinants** [*filename*]
    Optional character string.

    Default: off.  Default filename: DETS.

    Write out the enumerated list of determinants to the given *filename* or
    to the default filename if no filename is give.
**det** [*filename*]
    Synonym for **determinants**.
**hamiltonian** [*filename*]
    Optional character string.

    Default: off.  Default filename: HAMIL.

    Write out the diagonal and the non-zero off-diagonal elements of the
    Hamiltonian matrix to the given *filename*, or to the default filename if
    not filename is given.
**hamil** [*filename*]
    Synonym for **hamiltonian**.

Other options
^^^^^^^^^^^^^

**end**
    End of input.  Any subsequent lines in an input file are ignored.  It is
    only strictly required if the input is given via STDIN.

.. _HANDE.COMM:

Interacting with running calculations
------------------------------------

It is possible to interact with running calculations.

After each update cycle, HANDE checks for the existence of the file
HANDE.COMM in the current working directory for all processors. If HANDE.COMM
exists, then the file is read and any modified parameters are then used for the
rest of the calculation.  HANDE.COMM is deleted after it is read in to prevent
it from being detected on subsequent update cycles and to enable multiple
interactions with a running calculation.

HANDE.COMM has the same syntax as the input file.  Available options are:

**softexit**
    End the calculation immediately but still perform any
    post-processing (e.g. dumping out a restart file).  This is useful for
    cleanly terminating a converged calculation or cleanly stopping
    a calculation before the walltime is reached to allow it to be restarted.

    The watchdog.py (for PBS queue systems) and send_softexit.py (for other
    queue systems) scripts in the tools subdirectory are useful for running
    HANDE on a queueing system as they write **softexit** to HANDE.COMM a
    certain amount of time before the walltime is reached.
**varyshift_target** *varyshift_target*
    Long integer.

    Change the number of particles to be reached before the calculation starts
    varying the shift.  Meaningless if the calculation has already started
    varying the shift.  If *varyshift_target* is negative then the shift is
    immediately allowed to vary.
**tau** *tau*
    Real.

    Change the timestep to be used.
**zero_means**
    Reset the running averages of the shift and projected energy to 0.
**shift** *shift*
    Real.

    Adjust the current value of the shift.  Please note the impact this has on
    the mean; if used it is not a bad idea to also use **zero_means**.  If the
    calculation has already entered variable shift mode then the shift will
    still be updated every report cycle, otherwise this is equivalent to
    changing the **initial_shift** value.

Lz Symmetry
-----------

For cylindrically symmetrical systems, the Lz (z-component of orbital angular momentum)
operator commutes with the Hamiltonian, and this can be a convenient symmetry to conserve.
Lz is measured in units of hbar.
Normal FCIDUMP files do not contain orbitals which are eigenfunctions of the Lz operator,
so they must be transformed using post-processing.  The TransLz  script available from
https://github.com/ghb24/NECI_STABLE for this purpose. The FCIDUMP file header format has
been modified to include additional parameters: SYML, and SYMLZ which have a list of values
, one for each orbital.  SYML gives the magnitude of L for the orbital if known (or -20 if not)
but is not used.  SYMLZ give the eigenvalue of Lz (the m_l value).
Orbitals with defined values of Lz are likely to be complex-valued, but luckily the integrals
involving them are not, so although the FCIDUMP file must be translated, it still retains the
same format (see comments in src/read_in.F90 and src/molecular_integrals.F90 for details if 
you wish to create FCIDUMP files by other means).  NB these transformed integral files
require you to enforce Lz symmetry and will produce incorrect results if you do not.

Old (removed) functionality
---------------------------

Unused and **not useful** functionality is occasionally removed from HANDE, in
order to remove the maintenance burden for code that really has no benefit.  In
general, keeping failed experiments in the codebase is not helpful to
developers (more work) and users (not obvious if an option should or should not
be used).  When it transpires that something falls into the category, we may
hence remove it and detail it below.  If you are interested in resurrecting
this functionality, please dig through the git history and/or speak to
a developer.

folded-spectrum FCIQMC
    The folded-spectrum approach allows, in principle, access to excited states
    in FCIQMC via using the Hamiltonian :math:`(H-\epsilon)^2`, where
    :math:`epsilon` is an energy offset.  It emerged in practice to be very
    painful/impossible to converge to excited states for systems beyond the
    reach of conventional FCI.
defining an initiator determinant via a complete active space
    Originally the initiator space was defined by a population threshold and
    a complete active space (CAS).  It turns out that it is simpler to allow
    the initiator space to emerge naturally just through the population
    threshold (as used in later studies), whereas defining a CAS that is small
    but effective is not easy in large systems.  Furthermore, using just
    a population threshold makes the initiator approximation easier to extend
    to other algorithms (i.e. CCMC and DMQMC).
