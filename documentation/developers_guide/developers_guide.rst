HANDE Developers' Guide
=======================

Compiled from various email threads on (and before) the nascent hande-dev list.

git repository
--------------

The git repository is currently located at
hande@tycpc15.cmth.ph.ic.ac.uk:hande.git and can be cloned using:

.. code-block:: bash

    $ git clone hande@tycpc15.cmth.ph.ic.ac.uk:hande.git

If you would like access, please speak to one of the developers.  The rest of
this guide assumes you used the default remote name during the clone (i.e.
``origin``).  If this is not the case, we assume you are capable of
appropriately adjusting the commands given in the rest of the guide.

Precepts
--------

* All development happens in branches.
* Branches belong to a relevant namespace (feature/XXX indicates XXX is a branch
  (name) for a new feature, he/XXX for a HANDE enhancement (he), bug_fix/XXX for
  a bug fix, config/XXX for a new config file, etc).
* Branches are merged into master after review.  Merging between development
  branches should be avoided.
* Branches should be reviewed by one other person (at least) before merging into
  master.
* To review, send a pull request email (see git request-pull) to all developers
  (perhaps including a summary of work in the branch, which is not generated by
  request-pull!).  This should be viewed as starting a conversation on the work.
* Make changes prompted by the review and resend the pull request.  (This might
  take a few iterations.)
* After a happy conclusion to the review, merge into master.

Notes:

* We would like each commit to at least compile but don't expect each commit to
  be perfect in its own right!  This is extremely useful for using git-bisect
  when investigating regression errors.
* New functionality should be incorporated by new tests.  I intend to spend
  a day soon creating new tests and checking the code coverage (lcov is
  a wonderful tool) of the test suite.

See http://nvie.com/posts/a-successful-git-branching-model/ for
a popular variant on this approach.

The hope is that this approach will lead to better code and also (with a little
work) everyone will be more familiar/comfortable with the code that they're not
directly working on themselves.

Branch namespaces
-----------------

A (non-exhaustive!) list of namespaces we use for branches:

he/XXX
    for an enhancement to HANDE (usually a modification to existing algorithms).
bug_fix/XXX
    for a bug fix to a specific area of the codebase.
opt/XXX
    for optimisation work (please include performance details in the commit
    message!).
feature/XXX
    for a new feature (generally bigger than an enhancement).
doc/XXX
    for fixes/enhancements solely to the documentation.  (Often this kind of work
    is coupled to feature/enhancement development work and the documentation is
    updated directly in the relevant branches consisting mainly of changes to the
    source code.)
config/XXX
    for new configuration file(s)/updates to existing configurations.

Obviously there is some overlap between the he, feature and (to a lesser extent)
opt namespaces.  Broadly speaking, new algorithms or changes to existing algothims
which require a new input options are best suited to the feature namespace,
speed/memory improvements to opt/ and other improvements (code tidying, logging,
etc.) to the he namespace.

How to generate a pull request
------------------------------

First push your work to the relevant branch on the git sever and then generate
template text for the pull request:

.. code-block:: bash

    $ git request-pull startref origin [endref]

where startref (endref) is the commit you want to be reviewed from (to) and
origin is the name of remote configured to the git sever.  startref and endref
can be any way of referring to a specific commit and endref defaults to HEAD if
not given.  Usually the branch would have been created from master, in which
case you can simply do (even if master has been committed to since the branch
was created):

.. code-block:: bash

    $ git request-pull master origin

which generates (for example)::

    $ git request-pull master origin
    The following changes since commit 7a58a8d1a8f2e8af15df1c9946e7596078649d79:

      Updated the config files for cx2. (2013-12-09 11:07:52 +0000)

    are available in the git repository at:

      git@tyc-svn.cmth.ph.ic.ac.uk:hubbard_fciqmc config/cx2

    for you to fetch changes up to 1a5522648378f406d3e5fbd87e22e3768da490bc:

      Fixed typo cx2 config comment (2013-12-13 14:35:42 +0000)

    ----------------------------------------------------------------
    William Vigor (1):
          Fixed typo cx2 config comment

     config/cx2 |    2 +-
     1 file changed, 1 insertion(+), 1 deletion(-)

Copy and paste this text into your email client and send the pull request to
hande-dev@imperial.ac.uk (possibly with some additional text describing
motivation/benchmark results/etc).  If sendmail/exim4/other MTA is set up
properly (naturally the CMTH ones are) then

.. code-block:: bash

    $ git request-pull master origin | mail -s "Pull request" hande-dev@imperial.ac.uk

works as one would expect.

Merging to master
-----------------

Here's a workflow to make merging to master simple.  Remember that
with git it's extremely difficult to make permanently destructive changes
so if it goes wrong it can be fixed.

Before you start make sure your code compiles and passes the test suite.
Do not merge broken code into master.

Now make sure your master branch is up to date.  Here I do this in a fetch
then a pull just to see what else has changed.  I do a diff to be sure
I'm the same as the origin master.

.. code-block:: bash

    [master]$ git fetch
        remote: Counting objects: 340, done.
        remote: Compressing objects: 100% (182/182), done.
        remote: Total 200 (delta 137), reused 47 (delta 16)
        Receiving objects: 100% (200/200), 96.89 KiB, done.
        Resolving deltas: 100% (137/137), completed with 58 local objects.
        From tyc-svn.cmth.ph.ic.ac.uk:hubbard_fciqmc
           c17ef9e..2d8e130  master     -> origin/master
            ...

    [master]$ git pull
        Updating c17ef9e..2d8e130
        Fast-forward
         lib/local/parallel.F90       |    9 ++-------
         src/full_diagonalisation.F90 |   30 ++++++++++++------------------
         2 files changed, 14 insertions(+), 25 deletions(-)

    [master]$ git diff origin/master

The blank output from this indicates we're at origin/master.

I'm going to merge the branch bug_fix/rdm_init.  Crucially we use the --no-ff
flag to ensure that the merge creates a commit on master; this keeps the
history clean (by keeping development work in logical chunks after merging)
and also makes it very easy to roll-back and revert an entire feature if problems
are encounted.

.. code-block:: bash

    [master]$ git merge --no-ff bug_fix/rdm_init
        Merge made by the 'recursive' strategy.
         src/fciqmc_data.f90 |    2 +-
         1 file changed, 1 insertion(+), 1 deletion(-)

    [master]$ git log --graph --oneline --decorate | head
        *   647b7dd (HEAD, master) Merge branch 'bug_fix/rdm_init'
        |\
        | * 3c67d81 (bug_fix/rdm_init) Fix uninitialised doing_exact_rdm_eigv breaking fci
        * |   2d8e130 (origin/master, origin/HEAD) Merge branch 'bug_fix/small_fci_mpi'
        |\ \

This shows that a new commit has been created on master.

At this point it's possible that the merge needed some manual intervention.  It's fine
to make these changes directly and commit them in the merge to your local master.  If the merge
is starting to get messy it might be best to rebase first to make it easier.

Very importantly, you should now compile the code and run the tests, even if the merge
completed without any problems --- there might be unintented effects.  Only continue if the code
compiles and the tests pass.
If you need to make changes at this point, you can modify your local existing merge commit with

.. code-block:: bash

    [master]$ git commit --amend

Now we've made sure that the code works, all we do is push to the main repo

.. code-block:: bash

    [master]$ git push origin master
        Counting objects: 12, done.
        Delta compression using up to 12 threads.
        Compressing objects: 100% (7/7), done.
        Writing objects: 100% (7/7), 705 bytes, done.
        Total 7 (delta 5), reused 0 (delta 0)
        To git@tyc-svn.cmth.ph.ic.ac.uk:hubbard_fciqmc.git
           2d8e130..647b7dd  master -> master

    [master]$ git log --graph --oneline --decorate | head
        *   647b7dd (HEAD, origin/master, origin/HEAD, master) Merge branch 'bug_fix/rdm_init'
        |\
        | * 3c67d81 (bug_fix/rdm_init) Fix uninitialised doing_exact_rdm_eigv breaking fci
        * |   2d8e130 Merge branch 'bug_fix/small_fci_mpi'
        |\ \

Almost there.  We now ought to clean up the namespace to avoid old branch names hanging around
(the code of course will always stay).

.. code-block:: bash

     [master]$ git branch --delete bug_fix/rdm_init
     [master]$ git push origin --delete bug_fix/rdm_init

The list of branches merged into HEAD can be found by doing

.. code-block:: bash

     [master]$ git branch --all --merged

All done!

How to add a new test
---------------------

#.  Ensure the test suite passes with the master on your system.
#.  Now checkout the branch you're working on where you'd like to add the test.
#.  Rebuild HANDE so that the HANDE binary prints out the SHA1 hash of the current
    commit.  Make sure that there are no uncommitted changes to the source directory so
    that the benchmarks can be reproduced at a later date using the same binary.
#.  Inside test_suite create a new directory with a sensible name describing your test
    and change to it.
#.  Place the input files for your test in the directory.  You can have multiple input
    files in a single directory.
#.  git add your directory (this avoids having to separate out files generated during
    the tests).
#.  Add your directory name in [ ] to the jobconfig file.  This specifies that your tests
    should be included in the test suite.
#.  Pick some appropriate categories to also add your test to.
#.  Run testcode.py make-benchmarks to create new benchmarks e.g.

    .. code-block:: bash

        $ ../../testcode2/bin/testcode.py make-benchmarks
        Using executable: /home/Alex/code/HANDE/master/test_suite/../bin/hubbard.x.
        Test id: 09042014-2.
        Benchmark: 288ad50.

        ...

        Failed tests in:
            /home/Alex/code/HANDE/master/test_suite/H2-RHF-cc-pVTZ-Lz
        Not all tests passed.
        Create new benchmarks? [y/n] y
        Setting new benchmark in userconfig to be 6d161d0.

    Hopefully the only failed tests are your new tests (which you've checked).

    Alternatively if you can't run all the tests, you can just make a benchmark for your new test:

    .. code-block:: bash

        $ ../../testcode2/bin/testcode.py make-benchmarks -c H2-RHF-cc-pVTZ-Lz

        ...

        Setting new benchmark in userconfig to be 6d161d0.

    Now revert userconfig to the old version

    .. code-block:: bash

        $ git checkout userconfig

    and append the hash (6d161d0, in this case) to the benchmark = line in userconfig.
#.  Now remember to add the benchmark files and the jobconfig and userconfig files
    to the repository.

    .. code-block:: bash

        $ git add userconfig jobconfig */benchmark.out.6d161d0.inp*

    where 6d161d0 is the hash printed out at the end of the make-benchmarks

#.  Do a quick git status to make sure you haven't missed anything important out, and
    then you're ready to commit the tests:

    .. code-block:: bash

        $ git commit -m "Added new test H2-RHF-cc-pVTZ-Lz and benchmark 6d161d0."

    Remember you're committing to a branch not the master.
#.  Push this to the main repository and send round a pull request for review before its
    to be merged with master.

Unwanted experimental branches
------------------------------

Occasionally (frequently?!) we have tried something which didn't work out.  If
we don't want to keep any of the history, we can simply delete the local (and
if necessary) remote branches:

.. code-block:: bash

    $ git branch --delete unwanted_branch
    $ git push origin --delete unwanted_branch

But what about branches that we don't intend to continue working on in the near
future, would like to keep around but without cluttering up the main
repository, making it unclear which branches need some TLC before merging?  We
have a separate repository where such branches can be sent, to be resurrected
if desired later.  The repository is at
hande@tycpc15.cmth.ph.ic.ac.uk:hande_graveyard.git.  To push a local branch there:

.. code-block:: bash

    $ git remote add graveyard hande@tycpc15:hande_graveyard.git
    $ git push remote graveyard unwanted_branch

and then delete the branch (both local and remote) from the main repository
using the same commands as before.  If the branch is not local, then you can
either check it out and then do the push and delete (easier) or use a refspec:

.. code-block:: bash

    $ git push graveyard refs/remotes/origin/unwanted_branch:refs/head/unwanted_branch

where origin/unwanted_branch is the remote branch to be moved to the graveyard
repository.  The branch on origin can then be deleted as before.

FAQ
---

* Is it ever ok to commit directly to master?

  Yes, but only under very restricted circumstances!  If in doubt make a branch
  and let someone else do the merge.

  + I've got a quick bugfix which I've tested - can I commit it to master?

    Well done on the testing.  A bugfix should go in a bugfix/XXX branch.  It's
    a single command to create this.  Another few commands and you'll have an pull
    request email to the hande-dev list for review.

  + But it's a really quick fix!  Surely it won't hurt?

    If it will affect functionality (and potentially someone else's jobs) then
    it probably ought to be reviewed!  If it's a very minor corner case of which
    you're certain, then commit to a bugfix branch and then do the merge
    yourself.  Always do this via a branch - don't commit directly to master.
    It's sensible to ask the original author if you're fixing their code
    however.

  + But I need to use this fix to make my runs work.

    You can always run from a bugfix branch.  Because you've committed it to the
    central git repository, you'll have access to it everywhere.

  + What if I need this bugfix to develop a new feature?

    I don't know.  Ask James!  One option is to base your subsequent feature
    branch off the bug fix branch before it's merged into master (git handles
    merges very well!) or to cherry-pick the bug fix into your feature branch or
    make enough noise to get the bug fix merged quickly.

  + I've added some comments to clear up something.

    This might be ok to commit to master.  If you designed the
    feature/documentation then you're effectively reviewing yourself.  If it's
    somebody else's code it's polite to have consulted someone on this (either
    by email, or a review branch).

  + But I've modified a feature that only I'm using...

    It sounds like this should be in an enhancement branch he/XXX.  If only
    you're using it it's even more important than someone else review it.

  + I've accidentally committed some changes to my local master.  What do I do?

    Remember that you can always push to a different branch on the main server.

    .. code-block:: bash

       $ git push origin master:he/XXX

    would push your changes to the he/XXX branch.  It's probably better, however
    to checkout your changes locally to a branch, and then roll back your
    master, and then commit the branch:

    .. code-block:: bash

       $ git checkout -b he/XXX
       $ git push --set-upstream origin he/XXX
       $ git checkout master
       $ git reset --hard origin/master

    Note the last command resets your local master to the same state as that on
    origin.  You should adapt the reset command to set your master to point to
    the desired commit (ie the first commit shared with the new branch he/XXX).

  + Ok - I've gone through the review process and I'd like to try to merge to
    master myself.  Is it easy?

    Easy as pie.  There's a workflow in the section Merging to master

* I've got a local branch which I've been working on for some time, but I don't
  want the pain of a large merge at the end.

  This sounds like a workflow problem.  Some comments on this:

  + We need to lose the idea of personal branches (note the branch namespace is
    organised by topic rather than person), even though a branch might be
    written entirely/mostly by one person.  In that sense, long-running
    development work should be split into small, logical chunks, each of which
    is attached one-at-a-time in its own branch.  We have always regretted
    having (multiple) long-running branches.
  + When wrenched away from a WIP with only a distant prospect of future free
    time, a commit and push with light notes is a very worthwhile thing.  It's
    probably even worthwhile committing a plan before committing any actual
    code.  If these are fast and flexible enough they will hopefully not
    discourage, but actually encourage organization.  It might also encourage
    (*gasp*) collaboration.  Perhaps you could create a directory in
    documentation as a place for such notes/roadmaps, somewhere between Python's
    PEP system and informal topic-based TODO lists?
  + We are pretty happy for development branches to be regularly rebased against
    master (*note*: not merged in either direction), to lessen the pain of one
    final merge between two very disparate branches.

* This is all very well (and I enjoy the Socratic method), but I'm stuck with
  a huge branch I don't have time to merge.  What do I do?

  Commit it as a feature/XXX or he/XXX and ask for help from the hande-dev list.

* How do I review code?

  We're working on a workflow for this.  One method is to make a branch (if
  you're not already in one) and just add comments to the source.  It's helpful
  if the review is part of the git history (even if the comments never actually
  make it to the master).  We currently are using `watson-style
  <http://goosecode.com/watson/>`_ tags in comments for code review and
  discussion, for example:

  .. code-block:: fortran

     ! [review] - JSS: How about doing it this way?
     ! [reply] - AJWT: I thought about it but that causes problems due to X.

  where JSS and AJWT are the initials of the reviewer and code author
  respectively.

* Will *my* code actually get reviewed?

  We're all usually terribly busy and have very little time, but in a group
  effort a little from each person goes a long way.  If you review others' code
  then they're more likely to review yours.  Make it easy to review, by keeping
  it clean and the features short.  Remember, this kind of review is far more
  lightweight than peer review of publications, and should be able to slot into
  people's 'free' time.  (Each branch is far more lightweight than a paper.)
  A simple pull-request should be enough to get people to review.  This is
  rather intricately tied in with the idea of project management.
  Prodding/cajoling/bullying emails are all possible to aid the review

* What happens if no-one replies to the pull request?

  Here are some opinions:

  + I suggest that after an agreed upon time (X working days?) without even
    a "I'll review but am too busy until next week" reply, the author is free to
    merge it into master (but should be open to fixes/improvements to that work
    that others subsequently suggest).
  + Having been burdened with years-long old dirty branches from other projects,
    merging is certainly vital.  I don't think lack of review should stop
    merging, but it should prompt someone to ask why.
  + I would view it as a sign that the work is stable and relatively
    complete (for the time being) and is ready to be used by others/in
    production calculations.

* What about major (long-term) development work?  Perhaps anyone engaged in
  major projects should send out 'pull-requests' to request review of ongoing
  work periodically?

  Yes.

* Why are we bothering with review?  Surely it makes life more difficult?

  In an attempt to avoid heaps of

  #. completely redundant code
  #. untested code
  #. buggy code

  all ending up in master.  The main reason is to encourage something resembling
  a coherent design and prevent someone going off in a (technical) direction
  others don't agree with/can see major problems with.  A big plus is that it
  helps everyone become familiar with code that they didn't write (which is why
  doing code review is good for newcomers).

* PhD students are going to be working on this. How do you see the work they
  produce on a single project over the course of 3 years going? How often should
  their code be subject to review?

  PhD projects are never one single monolithicproject (or at least shouldn't
  be!).  The amount and frequency of review is probably a function of how
  experienced a developer is (in general and with HANDE).  Remember a pull
  request can simply be an indication that the developer would like to start
  a conversation rather than presenting the final result.  Developers should
  also be encouraged to consider how a development task can be broken down into
  smaller projects, which might well aid design and testing, as well as reducing
  horrible merge conflicts from attempting to merge long-standing branches.

* How do I signify a 'fine - no need to comment' commit?

  We suggest a pull request to the email list followed immediately by an email
  announcing that the requester had also merged into master (or perhaps just the
  latter email).
