#!/usr/bin/python
'''Produce a makefile for compiling the source code for a specified target/configuration.

Usage:
    mkconfig.py [options] configuration_file

A platform is defined using a simple ini file, consisting of three sections:
main, opt and dbg.  For instance::

    [main]
    cc = gcc
    ld = gcc
    libs = -larmadillo

    [opt]
    cflags = -O3

    [dbg]
    cflags = -g

The 'opt' and 'dbg' sections inherit settings from the 'main' section.  The settings
in 'opt' are used by default; the debug options can be selected by passing the
-g option to mkconfig.py.

Available options are:

fc
    Set the fortran compiler.
fflags
    Set flags to be passed to the fortran compiler during compilation.
cppdefs
    Set definitions to be used in the C pre-processing step.
cppflags
    Set flags to be used in the C pre-processing step.
ld
    Set the linker program.
ldflags
    Set flags to be passed to the linker during linking of the compiled objects.
libs
    Set libraries to be used during the linking step.
module_flag
    Set the flag used by the compiler which is used to specify the directory
    where module (.mod) files are placed when created and where they should be
    searched for.
'''

import ConfigParser
import optparse
import os
import pprint
import sys

#======================================================================
# Local settings.

PROGRAM_NAME='hubbard.x'

# Directory in which compiled objects are placed.
DEST='dest'

# Directory in which the compiled executable is placed.
EXE='bin'

# List of directories (colon-separated) containing the source files.
VPATH='src:lib'

# Space separated list of file extensions for the source files.
SOURCE_EXT='.f90 .F90'

#======================================================================

MAKEFILE_TEMPLATE='''# Generated by mkconfig.py.

SHELL=/bin/bash # For our sanity!

#-----
# Compiler configuration.

FC=%(fc)s
FFLAGS=-I $(DEST) %(fflags)s

CPPDEFS = %(cppdefs)s -D_VCS_VERSION='$(VCS_VERSION)'
CPPFLAGS = %(cppflags)s $(WORKING_DIR_CHANGES)

LD = %(ld)s
LDFLAGS = %(ldflags)s
LIBS = %(libs)s

#-----
# Directory structure and setup.

# Directories containing source files.
VPATH=%(VPATH)s

# Directory for objects.
DEST=%(DEST)s

# Directory for compiled executables.
EXE=%(EXE)s

# We put compiled objects and modules in $(DEST).  If it doesn't exist, create it.
make_dest:=$(shell test -e $(DEST) || mkdir -p $(DEST))

# We put the compiled executable in $(EXE).  If it doesn't exist, then create it.
make_exe:=$(shell test -e $(EXE) || mkdir -p $(EXE))

PROG=%(PROGRAM)s

#-----
# VCS info.

# Get the version control id.  Git only.  Outputs a string.
VCS_VERSION := $(shell set -o pipefail && echo -n \\" && ( git log --max-count=1 --pretty=format:%%H || echo -n 'Not under version control.' ) 2> /dev/null | tr -d '\\r\\n'  && echo -n \\")

# Test to see if the working directory contains changes.  Git only.  If the
# working directory contains changes (or is not under version control) then
# the _WORKING_DIR_CHANGES flag is set.
WORKING_DIR_CHANGES := $(shell git diff --quiet --cached && git diff --quiet 2> /dev/null || echo -n "-D_WORKING_DIR_CHANGES")

#-----
# Find source files and resultant object files.

# Source extensions.
EXTS = %(EXT)s

# Space separated list of source directories.
SRCDIRS := $(subst :, ,$(VPATH))

# Source filenames.
find_files = $(foreach ext,$(EXTS), $(wildcard $(dir)/*$(ext)))
SRCFILES := $(foreach dir,$(SRCDIRS),$(find_files))

# Objects (strip path and replace extension of source files with .o).
OBJ := $(addsuffix .o,$(basename $(notdir $(SRCFILES))))

# Full path to all objects.
OBJECTS := $(addprefix $(DEST)/, $(OBJ))

#-----
# Dependency file.

DEPEND = .depend

DEPEND_EXISTS := $(wildcard $(DEPEND))

# If the dependency file does not exist, then it is generated.  This 
# pass of make will not have the correct dependency knowledge though,
# so we force an exit.
ifneq ($(DEPEND_EXISTS),$(DEPEND))
\tTEST_DEPEND = no_depend
\tDEPEND_TARGET = $(DEPEND)
else
\tDEPEND_TARGET = depend_target
endif

#-----
# Compilation macros.

.SUFFIXES:
.SUFFIXES: $(EXTS)

# Files to be pre-processed then compiled.
$(DEST)/%%.o: %%.F90
\t$(FC) $(CPPDEFS) $(CPPFLAGS) -c $(FFLAGS) $< -o $@ %(module_flag)s$(DEST)

# Files to compiled directly.
$(DEST)/%%.o: %%.f90
\t$(FC) -c $(FFLAGS) $< -o $@ %(module_flag)s$(DEST)

#-----
# Goals.

.PHONY: clean test tests $(DEPEND_TARGET) depend help $(PROG) no_depend

# Compile program.
$(EXE)/$(PROG): $(TEST_DEPEND) $(OBJECTS)
\t$(MAKE) -B $(DEST)/environment_report.o
\ttest -e `dirname $@` || mkdir -p `dirname $@`
\t$(FC) -o $@ $(FFLAGS) $(LDFLAGS) -I $(DEST) $(OBJECTS) $(LIBS)

$(PROG): $(EXE)/$(PROG)

# Remove compiled objects and executable.
clean: 
\trm -f $(DEST)/*.{mod,o} $(EXE)/$(PROG)

# Build from scratch.
new: clean $(EXE)/$(PROG)

# Run tests.
test:
\tcd test_suite && testcode.py

tests: test

# Generate dependency file.
$(DEPEND_TARGET):
\ttools/sfmakedepend --file - --silent $(SRCFILES) --objdir \$$\(DEST\) --moddir \$$\(DEST\) > $(DEPEND)

depend: $(DEPEND_TARGET)

# Force exit if dependency file didn't exist as make didn't pickup the correct
# dependencies on this pass.
no_depend:
\t@echo "The required dependency file did not exist but has now been generated."
\t@echo "Please re-run make."
\texit 2

help:
\t@echo "Please use \`make <target>' where <target> is one of:"
\t@echo "  bin/hubbard.x        [default target] Compile program."
\t@echo "  hubbard.x            Compile program."
\t@echo "  clean                Remove the compiled objects."
\t@echo "  new                  Remove all previously compiled objects and re-compile."
\t@echo "  tests                Run test suite."
\t@echo "  test                 Run test suite."
\t@echo "  depend               Produce the .depend file containing the dependencies."
\t@echo "                       Requires the makedepf90 tool to be installed."
\t@echo "  help                 Print this help message."

#-----
# Include dependency file.

# $(DEPEND) will be generated if it doesn't exist.
include $(DEPEND)
'''

def parse_options(my_args):
    parser = optparse.OptionParser(usage='mkconfig.py [options] configuration_file')
    parser.add_option('-l', '--ls', action='store_true', default=False, help='Print list of available configurations.')
    parser.add_option('-d', '--dir', default='conf/', help='Set directory containing the configuration files. Default: %default.')
    parser.add_option('-g', '--debug', action='store_true', default=False, help='Use the debug settings.  Default: use optimised settings.')
    parser.add_option('-p', '--print', dest='print_conf', action='store_true', default=False, help='Print settings in configuration file specified, or all settings if no configuration file is specified.')
    (options, args) = parser.parse_args(my_args)
    if not (options.print_conf or options.ls) and len(args) != 1:
        print 'Incorrect arguments.'
        parser.print_help()
        sys.exit(1)
    elif len(args) == 1:
        config_file = args[0]
    else:
        config_file = None
    return (options, config_file)

def list_configs(config_dir):
    '''List all config files in config dir.  We assume only config files are in config_dir'''
    if os.path.isdir(config_dir):
        return os.listdir(config_dir)
    else:
        raise IOError, 'Config directory specified is not a directory: %s.' % (config_dir)

def parse_config(config_dir, config_file):
    '''Parse the configuration file config_file located in the directory config_dir.'''
    parser = ConfigParser.RawConfigParser()

    valid_sections = ['main', 'opt', 'dbg']

    valid_sections_upper = [s.upper() for s in valid_sections]

    valid_options = ['fc', 'fflags', 'cppdefs', 'cppflags', 'ld', 'ldflags', 'libs', 'module_flag']
    minimal_options = ['fc', 'ld', 'libs', 'module_flag']

    file = os.path.join(config_dir, config_file)

    parser.read(file)

    for s in parser.sections():
        if s not in valid_sections and s not in valid_sections_upper:
            raise IOError, 'Invalid section in configuration file: %s.' % (s)

    for s in valid_sections:
        if s not in parser.sections() and s.upper() not in parser.sections():
            raise IOError, 'Section not present in configuration file: %s.' % (s)             

    if not parser.sections():
        raise IOError, 'No sections in configuration file: %s.' % (s)

    config = {}

    for s in valid_sections:
        config[s] = dict(parser.items('main'))
        if s in parser.sections():
            config[s].update(parser.items(s))
        elif s.upper() in parser.sections():
            config[s].update(parser.items(s.upper()))

    for s in valid_sections:
        for opt in config[s].keys():
            if opt not in valid_options:
                raise IOError, 'Invalid option in configuration file: %s.' % (opt)
        # Fill in blanks
        for opt in valid_options:
            if opt not in config[s].keys():
                config[s][opt] = ''

    config.pop('main')

    for s in config.keys():
        # Check minimal options.
        for opt in minimal_options:
            if not config[s][opt]:
                raise IOError, 'Required option not set: %s' % (opt)
        # Treat module_flag specially: append a space if it doesn't end in =.
        # This is to allow the same template to be used no matter how the compiler
        # insists on handling this flag.
        if not config[s]['module_flag'][-1] == '=':
            config[s]['module_flag'] = '%s ' % (config[s]['module_flag'])

    return config

def create_makefile(config):
    '''Create the Makefile using the options given in the config dictionary.'''
    config.update(PROGRAM=PROGRAM_NAME, DEST=DEST, EXE=EXE, VPATH=VPATH, EXT=SOURCE_EXT)
    f=open('Makefile','w')
    f.write(MAKEFILE_TEMPLATE % config)
    f.close()

if __name__=='__main__':
    args=sys.argv[1:]
    (options, config_file) = parse_options(args)
    if options.ls:
        print 'Available configurations are: %s.' % (', '.join(list_configs(options.dir)))
    elif options.print_conf:
        if config_file:
            config_files = [config_file]
        else:
            config_files = list_configs(options.dir)
        for config_file in config_files:
            config = parse_config(options.dir, config_file)
            print 'Settings in configuration file: %s' % (config_file)
            pprint.pprint(config)
            print
    else:
        config = parse_config(options.dir, config_file)
        if options.debug:
            create_makefile(config['dbg'])
        else:
            create_makefile(config['opt'])
